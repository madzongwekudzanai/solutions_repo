<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="../../../img/favicon.ico" rel="shortcut icon"/>
<title>Problem 1 - Physics and Mathematics</title>
<link href="../../../css/theme.css" rel="stylesheet"/>
<link href="../../../css/theme_extra.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" rel="stylesheet"/>
<script>
        // Current page data
        var mkdocs_page_name = "Problem 1";
        var mkdocs_page_input_path = "1 Physics/5 Circuits/Problem_1.md";
        var mkdocs_page_url = null;
      </script>
<!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../.."> Physics and Mathematics
        </a><div role="search">
<form action="../../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input aria-label="Search docs" name="q" placeholder="Search docs" title="Type search term here" type="text"/>
</form>
</div>
</div>
<div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../..">Introduction</a>
</li>
</ul>
<p class="caption"><span class="caption-text">1 Physics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal">1 Mechanics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Gravity</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_2/">Problem 2</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_3/">Problem 3</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Waves</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../3%20Waves/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Electromagnetism</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../4%20Electromagnetism/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal current">5 Circuits</a>
<ul class="current">
<li class="toctree-l2 current"><a class="reference internal current" href="#">Problem 1</a>
<ul class="current">
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">6 Statistics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../6%20Statistics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">7 Measurements</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../7%20Measurements/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="Mobile navigation menu" class="wy-nav-top" role="navigation">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../..">Physics and Mathematics</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a aria-label="Docs" class="icon icon-home" href="../../.."></a></li>
<li class="breadcrumb-item">1 Physics</li>
<li class="breadcrumb-item">5 Circuits</li>
<li class="breadcrumb-item active">Problem 1</li>
<li class="wy-breadcrumbs-aside">
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div class="section" itemprop="articleBody">
<h1 id="problem-1">Problem 1</h1>
<h1 id="equivalent-resistance-using-graph-theory">Equivalent Resistance Using Graph Theory</h1>
<h2 id="introduction">Introduction</h2>
<p>Electrical circuits often contain complex arrangements of resistors that make manual analysis using series and parallel reduction tedious. Graph theory provides a robust mathematical framework to model and simplify such networks systematically. Each resistor is modeled as a weighted edge in a graph, and each junction becomes a node. By leveraging traversal algorithms, pattern detection, and graph simplification strategies, we can compute the equivalent resistance of any resistive network.</p>
<p>This approach not only simplifies analysis but also scales well to automated systems, as used in circuit simulation software and optimization tools.</p>
<hr/>
<h2 id="graph-theoretic-approach">Graph-Theoretic Approach</h2>
<h3 id="key-concepts">Key Concepts</h3>
<ul>
<li><strong>Vertices (nodes):</strong> Represent electrical junctions.</li>
<li><strong>Edges:</strong> Represent resistors, with weights equal to resistance values.</li>
<li><strong>Series Configuration:</strong> A chain of nodes with only two connected edges.</li>
<li><strong>Parallel Configuration:</strong> Multiple edges connecting the same pair of nodes.</li>
<li><strong>Supernode:</strong> A temporary node formed by merging nodes during reduction.</li>
</ul>
<hr/>
<h2 id="algorithm-overview">Algorithm Overview</h2>
<p>The algorithm operates iteratively to simplify the graph by reducing identifiable series and parallel subgraphs. It stops when the network is reduced to a single equivalent resistor between the input and output nodes.</p>
<h3 id="pseudocode">Pseudocode</h3>
<pre><code class="language-text">Function CalculateEquivalentResistance(graph, input_node, output_node):
    While the graph has more than 2 nodes:
        For each node v in graph:
            If v is part of a series chain:
                Replace the chain with a single equivalent resistor
            Else if v connects multiple resistors between same pair of nodes:
                Replace with parallel equivalent resistor

        If no simplifications are found:
            Use Y-Δ transformation or Kirchhoff’s laws

    Return resistance of edge between input_node and output_node
</code></pre>
<hr/>
<h2 id="python-implementation-using-networkx">Python Implementation (Using NetworkX)</h2>
<hr/>
<h2 id="test-cases">Test Cases</h2>
<h3 id="example-1-simple-series">Example 1: Simple Series</h3>
<ul>
<li><strong>Circuit:</strong> A → R1=5Ω → B</li>
<li><strong>Expected Result:</strong> 5Ω</li>
</ul>
<pre><code class="language-python">import networkx as nx

def parallel_resistance(resistors):
    return 1 / sum(1 / r for r in resistors)

def series_resistance(resistors):
    return sum(resistors)

def simplify_series(graph):
    modified = False
    for node in list(graph.nodes()):
        neighbors = list(graph.neighbors(node))
        if len(neighbors) == 2 and node not in ['A', 'B']:
            u, v = neighbors
            if graph.number_of_edges(u, node) == 1 and graph.number_of_edges(node, v) == 1:
                r1 = graph[u][node]['resistance']
                r2 = graph[node][v]['resistance']
                graph.add_edge(u, v, resistance=r1 + r2)
                graph.remove_node(node)
                modified = True
                break
    return modified

def simplify_parallel(graph):
    modified = False
    for u, v in list(graph.edges()):
        edges = list(graph.get_edge_data(u, v).values())
        if len(edges) &gt; 1:
            resistors = [d['resistance'] for d in edges]
            req = parallel_resistance(resistors)
            graph.remove_edges_from([(u, v)] * len(edges))
            graph.add_edge(u, v, resistance=req)
            modified = True
            break
    return modified

def calculate_equivalent_resistance(graph, input_node, output_node):
    G = graph.copy()
    while simplify_series(G) or simplify_parallel(G):
        pass
    return G[input_node][output_node]['resistance']

G = nx.Graph()
G.add_edge('A', 'B', resistance=5)
print(calculate_equivalent_resistance(G, 'A', 'B'))  # Output: 5
</code></pre>
<hr/>
<h3 id="example-2-parallel-combination">Example 2: Parallel Combination</h3>
<ul>
<li><strong>Circuit:</strong> A → R1=6Ω // R2=3Ω → B</li>
<li><strong>Expected:</strong><br/>
<span class="arithmatex">\( R\_{eq} = \left(rac{1}{6} + rac{1}{3}
  ight)^{-1} = 2 \Omega \)</span></li>
</ul>
<pre><code class="language-python">import networkx as nx

def parallel_resistance(resistors):
    return 1 / sum(1 / r for r in resistors)

def series_resistance(resistors):
    return sum(resistors)

def simplify_series(graph):
    modified = False
    for node in list(graph.nodes()):
        neighbors = list(graph.neighbors(node))
        if len(neighbors) == 2 and node not in ['A', 'B']:
            u, v = neighbors
            if graph.number_of_edges(u, node) == 1 and graph.number_of_edges(node, v) == 1:
                r1 = list(graph.get_edge_data(u, node).values())[0]['resistance']
                r2 = list(graph.get_edge_data(node, v).values())[0]['resistance']
                graph.add_edge(u, v, resistance=r1 + r2)
                graph.remove_node(node)
                modified = True
                break
    return modified

def simplify_parallel(graph):
    modified = False
    for u, v in list(graph.edges()):
        edge_data = graph.get_edge_data(u, v)
        if edge_data and len(edge_data) &gt; 1:
            resistors = [d['resistance'] for d in edge_data.values()]
            req = parallel_resistance(resistors)
            keys = list(edge_data.keys())
            for k in keys:
                graph.remove_edge(u, v, key=k)
            graph.add_edge(u, v, resistance=req)
            modified = True
            break
    return modified

def calculate_equivalent_resistance(graph, input_node, output_node):
    G = graph.copy()
    while simplify_series(G) or simplify_parallel(G):
        pass
    return G[input_node][output_node][0]['resistance']  # Key is 0 after simplification

G = nx.MultiGraph()
G.add_edge('A', 'B', resistance=6)
G.add_edge('A', 'B', resistance=3)

print(calculate_equivalent_resistance(G, 'A', 'B'))  # Output: 2.0
</code></pre>
<hr/>
<h3 id="example-3-nested-configuration">Example 3: Nested Configuration</h3>
<ul>
<li><strong>Circuit:</strong></li>
</ul>
<p><code>A - R1(2Ω) - C - R2(4Ω) - B
         \             /
         R3(6Ω) ------</code></p>
<ul>
<li>
<p><strong>Step 1:</strong> R2 and R3 are in parallel:<br/>
<span class="arithmatex">\( R\_{23} = \left(rac{1}{4} + rac{1}{6}
  ight)^{-1} = 2.4 \Omega \)</span></p>
</li>
<li>
<p><strong>Step 2:</strong> R1 and R*{23} in series:<br/>
<span class="arithmatex">\( R*{eq} = 2 + 2.4 = 4.4 \Omega \)</span></p>
</li>
</ul>
<pre><code class="language-python">import networkx as nx

def parallel_resistance(resistors):
    return 1 / sum(1 / r for r in resistors)

def series_resistance(resistors):
    return sum(resistors)

def simplify_series(graph):
    modified = False
    for node in list(graph.nodes()):
        neighbors = list(graph.neighbors(node))
        if len(neighbors) == 2 and node not in ['A', 'B']:
            u, v = neighbors
            if graph.number_of_edges(u, node) == 1 and graph.number_of_edges(node, v) == 1:
                r1 = list(graph.get_edge_data(u, node).values())[0]['resistance']
                r2 = list(graph.get_edge_data(node, v).values())[0]['resistance']
                graph.add_edge(u, v, resistance=r1 + r2)
                graph.remove_node(node)
                modified = True
                break
    return modified

def simplify_parallel(graph):
    modified = False
    for u, v in list(graph.edges()):
        edge_data = graph.get_edge_data(u, v)
        if edge_data and len(edge_data) &gt; 1:
            resistors = [d['resistance'] for d in edge_data.values()]
            req = parallel_resistance(resistors)
            keys = list(edge_data.keys())
            for k in keys:
                graph.remove_edge(u, v, key=k)
            graph.add_edge(u, v, resistance=req)
            modified = True
            break
    return modified

def calculate_equivalent_resistance(graph, input_node, output_node):
    G = graph.copy()
    while simplify_series(G) or simplify_parallel(G):
        pass
    return G[input_node][output_node][0]['resistance']  # Key is 0 after simplification

G = nx.MultiGraph()
G.add_edge('A', 'C', resistance=2)
G.add_edge('C', 'B', resistance=4)
G.add_edge('C', 'B', resistance=6)
print(calculate_equivalent_resistance(G, 'A', 'B'))  # Output: 4.4
</code></pre>
<hr/>
<h2 id="plotting-resistance-vs-node-count">Plotting Resistance vs. Node Count</h2>
<p>Let’s visualize how equivalent resistance evolves in a ladder network. <a href="https://colab.research.google.com/drive/1NJXC4JYxTBp6Lzhj9QoSDNdsLoz4mmBo" target="_blank">Learn more</a>:</p>
<p><img alt="Resistance vs. Node Count" src="../resistance_node.png"/></p>
<pre><code class="language-python">import matplotlib.pyplot as plt
from matplotlib.pyplot import figure
import networkx as nx

def parallel_resistance(resistors):
    return 1 / sum(1 / r for r in resistors)

def series_resistance(resistors):
    return sum(resistors)

def simplify_series(graph, input_node, output_node):
    modified = False
    for node in list(graph.nodes()):
        if node in [input_node, output_node]:
            continue
        neighbors = list(graph.neighbors(node))
        if len(neighbors) == 2:
            u, v = neighbors
            if graph.number_of_edges(u, node) == 1 and graph.number_of_edges(node, v) == 1:
                r1 = list(graph.get_edge_data(u, node).values())[0]['resistance']
                r2 = list(graph.get_edge_data(node, v).values())[0]['resistance']
                graph.add_edge(u, v, resistance=r1 + r2)
                graph.remove_node(node)
                modified = True
                break
    return modified

def simplify_parallel(graph):
    modified = False
    for u, v in list(graph.edges()):
        edge_data = graph.get_edge_data(u, v)
        if edge_data and len(edge_data) &gt; 1:
            resistors = [d['resistance'] for d in edge_data.values()]
            req = parallel_resistance(resistors)
            keys = list(edge_data.keys())
            for k in keys:
                graph.remove_edge(u, v, key=k)
            graph.add_edge(u, v, resistance=req)
            modified = True
            break
    return modified

def calculate_equivalent_resistance(graph, input_node, output_node):
    G = graph.copy()
    while simplify_series(G, input_node, output_node) or simplify_parallel(G):
        pass
    return G[input_node][output_node][0]['resistance']

def build_ladder(n, r1=1, r2=2):
    G = nx.MultiGraph()
    for i in range(n):
        G.add_edge(f'N{i}', f'N{i+1}', resistance=r1)
        G.add_edge(f'N{i}', f'N{i+1}', resistance=r2)
    return G

# Ladder sizes
nodes = range(1, 11)

# Define scenarios: (label, r1, r2)
scenarios = [
    ("r1=1Ω, r2=2Ω", 1, 2),
    ("r1=1Ω, r2=1Ω", 1, 1),
    ("r1=2Ω, r2=1Ω", 2, 1),
    ("r1=5Ω, r2=5Ω", 5, 5),
    ("r1=1Ω, r2=10Ω", 1, 10)
]

# Plot setup
figure(figsize=(12, 8))
for label, r1, r2 in scenarios:
    resistances = []
    for n in nodes:
        G = build_ladder(n, r1, r2)
        input_node = 'N0'
        output_node = f'N{n}'
        R_eq = calculate_equivalent_resistance(G, input_node, output_node)
        resistances.append(R_eq)
    plt.plot(nodes, resistances, marker='o', label=label)

# Labels and legend
plt.title('Equivalent Resistance vs. Ladder Steps (Multiple Scenarios)', fontsize=14)
plt.xlabel('Number of Ladder Rungs', fontsize=12)
plt.ylabel('Equivalent Resistance (Ω)', fontsize=12)
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()
</code></pre>
<hr/>
<h2 id="efficiency-analysis">Efficiency Analysis</h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Time Complexity</th>
</tr>
</thead>
<tbody>
<tr>
<td>Series Detection</td>
<td><span class="arithmatex">\( O(n) \)</span></td>
</tr>
<tr>
<td>Parallel Detection</td>
<td><span class="arithmatex">\( O(n^2) \)</span></td>
</tr>
<tr>
<td>Overall Simplification</td>
<td><span class="arithmatex">\( O(n^2) \)</span> worst-case</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Space Complexity:</strong> <span class="arithmatex">\( O(n + m) \)</span><br/>
  where <span class="arithmatex">\( n \)</span> is number of nodes and <span class="arithmatex">\( m \)</span> is number of edges.</li>
</ul>
<hr/>
<h2 id="limitations">Limitations</h2>
<ul>
<li>Cannot yet handle <strong>Delta-Wye</strong> (Δ-Y) transformations.</li>
<li>May get stuck if no identifiable series or parallel patterns are found.</li>
<li>Not optimized for <strong>dense cyclic</strong> graphs.</li>
</ul>
<hr/>
<h2 id="improvements-and-extensions">Improvements and Extensions</h2>
<ul>
<li>Add <strong>Y-Δ transformations</strong> for full topology support.</li>
<li>Implement <strong>Kirchhoff's Matrix Methods</strong> using node-voltage analysis.</li>
<li>Extend for <strong>AC circuits</strong> using complex impedances.</li>
<li>Improve with symbolic computation (e.g., SymPy) for algebraic analysis.</li>
</ul>
<hr/>
<h2 id="conclusion">Conclusion</h2>
<p>Graph theory offers an elegant and scalable way to analyze resistive circuits. By iteratively detecting and reducing series and parallel configurations, we can compute equivalent resistance for even complex networks. This method supports automation, generalization, and integration with modern simulation tools, making it invaluable in education, research, and engineering design.</p>
<hr/>
</div>
</div><footer>
<div aria-label="Footer Navigation" class="rst-footer-buttons" role="navigation">
<a class="btn btn-neutral float-left" href="../../4%20Electromagnetism/Problem_1/" title="Problem 1"><span class="icon icon-circle-arrow-left"></span> Previous</a>
<a class="btn btn-neutral float-right" href="../../6%20Statistics/Problem_1/" title="Problem 1">Next <span class="icon icon-circle-arrow-right"></span></a>
</div>
<hr/>
<div role="contentinfo">
<!-- Copyright etc -->
</div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
</div>
</div>
</section>
</div>
<div aria-label="Versions" class="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span><a href="../../4%20Electromagnetism/Problem_1/" style="color: #fcfcfc">« Previous</a></span>
<span><a href="../../6%20Statistics/Problem_1/" style="color: #fcfcfc">Next »</a></span>
</span>
</div>
<script src="../../../js/jquery-3.6.0.min.js"></script>
<script>var base_url = "../../..";</script>
<script src="../../../js/theme_extra.js"></script>
<script src="../../../js/theme.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script src="../../../search/main.js"></script>
<script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>
</body>
</html>
