{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Projectile Motion Analysis and Simulation Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation Projectile motion is a fundamental topic in classical mechanics, describing the motion of an object launched into the air under the influence of gravity. It plays a crucial role in various real-world applications, such as ballistics, sports, and space exploration. Understanding projectile motion requires analyzing both horizontal and vertical components independently, assuming no external forces except gravity (neglecting air resistance initially). By exploring its equations, derivations, and computational approaches, we can gain deeper insights into the factors influencing projectile trajectory. 1.1 Equations of Motion The motion of a projectile launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) is governed by the fundamental kinematic equations. 1.1.1 Horizontal Motion Since there is no horizontal acceleration (neglecting air resistance), the horizontal displacement is given by: \\[ x = v_0 \\cos(\\theta) t \\] where: \\( x \\) = horizontal displacement \\( v_0 \\) = initial velocity \\( \\theta \\) = launch angle \\( t \\) = time 1.1.2 Vertical Motion The vertical motion is influenced by gravity \\( g \\) , leading to the equation: \\[ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] where: \\( y \\) = vertical displacement \\( g \\) = acceleration due to gravity (9.81 m/s\u00b2) 1.2 Derivation of Key Equations 1.2.1 Time of Flight The total time of flight occurs when the projectile returns to the ground (i.e., \\( y = 0 \\) ). Setting the vertical displacement equation to zero: \\[ 0 = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] Factoring out \\( t \\) : \\[ t (v_0 \\sin(\\theta) - \\frac{1}{2} g t) = 0 \\] Solving for \\( t \\) : \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] 1.2.2 Range of the Projectile The range \\( R \\) is the horizontal distance traveled before the projectile lands: \\[ R = v_0 \\cos(\\theta) t_f \\] Substituting \\( t_f \\) from above: \\[ R = v_0 \\cos(\\theta) \\times \\frac{2 v_0 \\sin(\\theta)}{g} \\] Using the trigonometric identity \\( 2 \\sin(\\theta) \\cos(\\theta) = \\sin(2\\theta) \\) , we get: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] 1.2.3 Maximum Height At the peak, the vertical velocity is zero \\( (v_y = 0) \\) . Using the kinematic equation: \\[ v_y^2 = v_0^2 \\sin^2(\\theta) - 2 g H \\] Setting \\( v_y = 0 \\) : \\[ 0 = v_0^2 \\sin^2(\\theta) - 2 g H \\] Solving for \\( H \\) : \\[ H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\] 1.3 Effects of Air Resistance Without air resistance, projectiles follow a parabolic trajectory . However, with air resistance, the motion becomes more complex due to a drag force \\( F_d \\) , given by: \\[ F_d = \\frac{1}{2} C_d \\rho A v^2 \\] where: \\( C_d \\) = drag coefficient (depends on object shape) \\( \\rho \\) = air density (kg/m\u00b3) \\( A \\) = cross-sectional area (m\u00b2) \\( v \\) = velocity (m/s) 1.4 Numerical Computation with Air Resistance With air resistance, the equations of motion become nonlinear differential equations: 1.4.1 Horizontal Motion with Drag \\[ m \\frac{dv_x}{dt} = -\\frac{1}{2} C_d \\rho A v v_x \\] 1.4.2 Vertical Motion with Drag \\[ m \\frac{dv_y}{dt} = -mg - \\frac{1}{2} C_d \\rho A v v_y \\] where \\( v_x \\) and \\( v_y \\) are the horizontal and vertical velocity components. These equations require numerical methods (such as Euler\u2019s method or Runge-Kutta) for solving. 1.5 Summary of Important Equations Quantity Equation Horizontal Position \\( x = v_0 \\cos(\\theta) t \\) Vertical Position \\( y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\) Time of Flight \\( t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\) Range \\( R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\) Maximum Height \\( H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\) Drag Force \\( F_d = \\frac{1}{2} C_d \\rho A v^2 \\) 2. Analytical Analysis of Range This section plots range vs. launch angle without air resistance. Learn more. import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # gravitational acceleration (m/s\u00b2) v0 = 10 # initial velocity (m/s) # Angle range (0\u00b0 to 90\u00b0) theta = np.linspace(0, 90, 100) theta_rad = np.radians(theta) # Convert to radians # Compute range R = (v0**2 * np.sin(2 * theta_rad)) / g # Plot range vs. angle plt.figure(figsize=(12, 7.5)) plt.plot(theta, R, label=f'Initial velocity = {v0} m/s') plt.xlabel('Launch Angle (\u00b0)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show() 3. Numerical Simulation with Air Resistance Here, we use ODE solvers to simulate projectile motion with drag. Learn more. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # Gravity (m/s\u00b2) rho = 1.225 # Air density (kg/m\u00b3) Cd = 0.47 # Drag coefficient (sphere) A = 0.01 # Cross-sectional area (m\u00b2) m = 0.145 # Mass of projectile (kg) (e.g., baseball) def equations(t, state, Cd, A, m, rho): \"\"\"Differential equations for projectile motion with air resistance.\"\"\" x, y, vx, vy = state v = np.sqrt(vx**2 + vy**2) # Speed drag = (0.5 * Cd * rho * A * v**2) / m # Drag acceleration ax = -drag * (vx / v) # Drag in x-direction ay = -g - drag * (vy / v) # Drag in y-direction return [vx, vy, ax, ay] def solve_projectile(v0, theta_deg, Cd=0.47): \"\"\"Solve projectile motion with air resistance using numerical integration.\"\"\" theta = np.radians(theta_deg) vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) # Initial conditions state0 = [0, 0, vx0, vy0] # Solve using solve_ivp t_span = (0, 5) # Time range t_eval = np.linspace(0, 5, 300) # Time points for solution sol = solve_ivp(equations, t_span, state0, t_eval=t_eval, args=(Cd, A, m, rho)) return sol.t, sol.y[0], sol.y[1] # Time, x, y def plot_trajectory(arr_args): \"\"\"Plots projectile motion with adjustable parameters.\"\"\" plt.figure(figsize=(12, 7.5)) for item in arr_args: v0, theta_deg, Cd = item t, x, y = solve_projectile(v0, theta_deg, Cd) plt.plot(x, y, label=f'v0={v0} m/s, \u03b8={theta_deg}\u00b0, Cd={Cd}') plt.xlabel('Distance (m)') plt.ylabel('Height (m)') plt.title('Projectile Motion with Air Resistance') plt.legend() plt.grid() plt.ylim(0) # Ensure ground level is visible plt.show() # Example Plot plot_trajectory([(40, 45, 0.47), (40, 45, 0.2), (40, 45, 0.1), (40, 40, 0.47), (40, 30, 0.47), (40, 20, 0.47), (30, 40, 0.47), (20, 40, 0.47), (15, 40, 0.47)]) 4. Interactive Simulation This section adds sliders for interactive tuning of launch parameters. Learn more. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp import ipywidgets as widgets from IPython.display import display # Constants g = 9.81 # Gravity (m/s\u00b2) rho = 1.225 # Air density (kg/m\u00b3) A = 0.01 # Cross-sectional area (m\u00b2) m = 0.145 # Mass of projectile (kg) (e.g., baseball) # Define equations of motion def equations(t, state, Cd, A, m, rho): x, y, vx, vy = state v = np.sqrt(vx**2 + vy**2) # Speed magnitude drag = (0.5 * Cd * rho * A * v**2) / m # Drag force ax = -drag * (vx / v) # Acceleration in x ay = -g - drag * (vy / v) # Acceleration in y return [vx, vy, ax, ay] # Solve equations using Runge-Kutta def solve_projectile(v0, theta_deg, Cd): theta = np.radians(theta_deg) vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) state0 = [0, 0, vx0, vy0] t_span = (0, 5) t_eval = np.linspace(0, 5, 300) sol = solve_ivp(equations, t_span, state0, t_eval=t_eval, args=(Cd, A, m, rho)) return sol.y[0], sol.y[1] # Return x and y coordinates # Function to update plot dynamically def update_plot(v0, theta_deg, Cd): fig, ax = plt.subplots(figsize=(12, 7.5)) # Create new figure each time ax.set_xlabel('Distance (m)') ax.set_ylabel('Height (m)') ax.set_title('Projectile Motion with Air Resistance') ax.set_xlim(0, 50) # Set fixed axis limits ax.set_ylim(0, 15) ax.grid() x, y = solve_projectile(v0, theta_deg, Cd) # Solve motion equations ax.plot(x, y, label=f'v0={v0} m/s, \u03b8={theta_deg}\u00b0, Cd={Cd}', color='b') ax.legend() plt.show() # Display updated plot # Interactive widgets v0_slider = widgets.FloatSlider(value=20, min=5, max=50, step=1, description='v0 (m/s)') theta_slider = widgets.FloatSlider(value=45, min=0, max=90, step=1, description='Angle (\u00b0)') Cd_slider = widgets.FloatSlider(value=0.47, min=0, max=1.5, step=0.05, description='Cd (Drag)') # Link widgets with update function out = widgets.interactive_output(update_plot, {'v0': v0_slider, 'theta_deg': theta_slider, 'Cd': Cd_slider}) # Display the widgets and plot ui = widgets.VBox([v0_slider, theta_slider, Cd_slider]) display(ui, out) 5. Launch from Different Heights We modify our simulation to allow for launch at y\u2080\u22600. This affects the time of flight calculation. Learn more. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # Gravity (m/s\u00b2) rho = 1.225 # Air density (kg/m\u00b3) Cd = 0.47 # Drag coefficient (sphere) A = 0.01 # Cross-sectional area (m\u00b2) m = 0.145 # Mass of projectile (kg) (e.g., baseball) def equations(t, state, Cd, A, m, rho): \"\"\"Differential equations for projectile motion with air resistance.\"\"\" x, y, vx, vy = state v = np.sqrt(vx**2 + vy**2) # Speed drag = (0.5 * Cd * rho * A * v**2) / m # Drag acceleration ax = -drag * (vx / v) # Drag in x-direction ay = -g - drag * (vy / v) # Drag in y-direction return [vx, vy, ax, ay] def solve_projectile_height(v0, theta_deg, y0, Cd=0.47): \"\"\"Solve projectile motion with different initial heights.\"\"\" theta = np.radians(theta_deg) vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) # Initial conditions state0 = [0, y0, vx0, vy0] # Solve sol = solve_ivp(equations, (0, 10), state0, t_eval=np.linspace(0, 10, 500), args=(Cd, A, m, rho)) return sol.t, sol.y[0], sol.y[1] # Example Plot def plot_trajectory(para_list): plt.figure(figsize=(12, 7.5)) for para in para_list: v0, theta_deg, Cd, init_height = para t, x, y = solve_projectile_height(v0, theta_deg, init_height, Cd) plt.plot(x, y, label=f'v0={v0} m/s, \u03b8={theta_deg}\u00b0, Cd={Cd}, y0={init_height}m') plt.xlabel('Distance (m)') plt.ylabel('Height (m)') plt.title('Projectile Motion with Air Resistance') plt.legend() plt.grid() plt.ylim(0) plt.show() # Example: Launch from different height plot_trajectory([(20, 45, 0.47, 3), (20, 45, 0.47, 6), (20, 45, 0.47, 9), (20, 45, 0.47, 12)])","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-analysis-and-simulation","text":"","title":"Projectile Motion Analysis and Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion is a fundamental topic in classical mechanics, describing the motion of an object launched into the air under the influence of gravity. It plays a crucial role in various real-world applications, such as ballistics, sports, and space exploration. Understanding projectile motion requires analyzing both horizontal and vertical components independently, assuming no external forces except gravity (neglecting air resistance initially). By exploring its equations, derivations, and computational approaches, we can gain deeper insights into the factors influencing projectile trajectory.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-equations-of-motion","text":"The motion of a projectile launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) is governed by the fundamental kinematic equations.","title":"1.1 Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#111-horizontal-motion","text":"Since there is no horizontal acceleration (neglecting air resistance), the horizontal displacement is given by: \\[ x = v_0 \\cos(\\theta) t \\] where: \\( x \\) = horizontal displacement \\( v_0 \\) = initial velocity \\( \\theta \\) = launch angle \\( t \\) = time","title":"1.1.1 Horizontal Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#112-vertical-motion","text":"The vertical motion is influenced by gravity \\( g \\) , leading to the equation: \\[ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] where: \\( y \\) = vertical displacement \\( g \\) = acceleration due to gravity (9.81 m/s\u00b2)","title":"1.1.2 Vertical Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-derivation-of-key-equations","text":"","title":"1.2 Derivation of Key Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#121-time-of-flight","text":"The total time of flight occurs when the projectile returns to the ground (i.e., \\( y = 0 \\) ). Setting the vertical displacement equation to zero: \\[ 0 = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] Factoring out \\( t \\) : \\[ t (v_0 \\sin(\\theta) - \\frac{1}{2} g t) = 0 \\] Solving for \\( t \\) : \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\]","title":"1.2.1 Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#122-range-of-the-projectile","text":"The range \\( R \\) is the horizontal distance traveled before the projectile lands: \\[ R = v_0 \\cos(\\theta) t_f \\] Substituting \\( t_f \\) from above: \\[ R = v_0 \\cos(\\theta) \\times \\frac{2 v_0 \\sin(\\theta)}{g} \\] Using the trigonometric identity \\( 2 \\sin(\\theta) \\cos(\\theta) = \\sin(2\\theta) \\) , we get: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"1.2.2 Range of the Projectile"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#123-maximum-height","text":"At the peak, the vertical velocity is zero \\( (v_y = 0) \\) . Using the kinematic equation: \\[ v_y^2 = v_0^2 \\sin^2(\\theta) - 2 g H \\] Setting \\( v_y = 0 \\) : \\[ 0 = v_0^2 \\sin^2(\\theta) - 2 g H \\] Solving for \\( H \\) : \\[ H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\]","title":"1.2.3 Maximum Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-effects-of-air-resistance","text":"Without air resistance, projectiles follow a parabolic trajectory . However, with air resistance, the motion becomes more complex due to a drag force \\( F_d \\) , given by: \\[ F_d = \\frac{1}{2} C_d \\rho A v^2 \\] where: \\( C_d \\) = drag coefficient (depends on object shape) \\( \\rho \\) = air density (kg/m\u00b3) \\( A \\) = cross-sectional area (m\u00b2) \\( v \\) = velocity (m/s)","title":"1.3 Effects of Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#14-numerical-computation-with-air-resistance","text":"With air resistance, the equations of motion become nonlinear differential equations:","title":"1.4 Numerical Computation with Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#141-horizontal-motion-with-drag","text":"\\[ m \\frac{dv_x}{dt} = -\\frac{1}{2} C_d \\rho A v v_x \\]","title":"1.4.1 Horizontal Motion with Drag"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#142-vertical-motion-with-drag","text":"\\[ m \\frac{dv_y}{dt} = -mg - \\frac{1}{2} C_d \\rho A v v_y \\] where \\( v_x \\) and \\( v_y \\) are the horizontal and vertical velocity components. These equations require numerical methods (such as Euler\u2019s method or Runge-Kutta) for solving.","title":"1.4.2 Vertical Motion with Drag"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#15-summary-of-important-equations","text":"Quantity Equation Horizontal Position \\( x = v_0 \\cos(\\theta) t \\) Vertical Position \\( y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\) Time of Flight \\( t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\) Range \\( R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\) Maximum Height \\( H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\) Drag Force \\( F_d = \\frac{1}{2} C_d \\rho A v^2 \\)","title":"1.5 Summary of Important Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analytical-analysis-of-range","text":"This section plots range vs. launch angle without air resistance. Learn more. import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # gravitational acceleration (m/s\u00b2) v0 = 10 # initial velocity (m/s) # Angle range (0\u00b0 to 90\u00b0) theta = np.linspace(0, 90, 100) theta_rad = np.radians(theta) # Convert to radians # Compute range R = (v0**2 * np.sin(2 * theta_rad)) / g # Plot range vs. angle plt.figure(figsize=(12, 7.5)) plt.plot(theta, R, label=f'Initial velocity = {v0} m/s') plt.xlabel('Launch Angle (\u00b0)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show()","title":"2. Analytical Analysis of Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-numerical-simulation-with-air-resistance","text":"Here, we use ODE solvers to simulate projectile motion with drag. Learn more. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # Gravity (m/s\u00b2) rho = 1.225 # Air density (kg/m\u00b3) Cd = 0.47 # Drag coefficient (sphere) A = 0.01 # Cross-sectional area (m\u00b2) m = 0.145 # Mass of projectile (kg) (e.g., baseball) def equations(t, state, Cd, A, m, rho): \"\"\"Differential equations for projectile motion with air resistance.\"\"\" x, y, vx, vy = state v = np.sqrt(vx**2 + vy**2) # Speed drag = (0.5 * Cd * rho * A * v**2) / m # Drag acceleration ax = -drag * (vx / v) # Drag in x-direction ay = -g - drag * (vy / v) # Drag in y-direction return [vx, vy, ax, ay] def solve_projectile(v0, theta_deg, Cd=0.47): \"\"\"Solve projectile motion with air resistance using numerical integration.\"\"\" theta = np.radians(theta_deg) vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) # Initial conditions state0 = [0, 0, vx0, vy0] # Solve using solve_ivp t_span = (0, 5) # Time range t_eval = np.linspace(0, 5, 300) # Time points for solution sol = solve_ivp(equations, t_span, state0, t_eval=t_eval, args=(Cd, A, m, rho)) return sol.t, sol.y[0], sol.y[1] # Time, x, y def plot_trajectory(arr_args): \"\"\"Plots projectile motion with adjustable parameters.\"\"\" plt.figure(figsize=(12, 7.5)) for item in arr_args: v0, theta_deg, Cd = item t, x, y = solve_projectile(v0, theta_deg, Cd) plt.plot(x, y, label=f'v0={v0} m/s, \u03b8={theta_deg}\u00b0, Cd={Cd}') plt.xlabel('Distance (m)') plt.ylabel('Height (m)') plt.title('Projectile Motion with Air Resistance') plt.legend() plt.grid() plt.ylim(0) # Ensure ground level is visible plt.show() # Example Plot plot_trajectory([(40, 45, 0.47), (40, 45, 0.2), (40, 45, 0.1), (40, 40, 0.47), (40, 30, 0.47), (40, 20, 0.47), (30, 40, 0.47), (20, 40, 0.47), (15, 40, 0.47)])","title":"3. Numerical Simulation with Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-interactive-simulation","text":"This section adds sliders for interactive tuning of launch parameters. Learn more. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp import ipywidgets as widgets from IPython.display import display # Constants g = 9.81 # Gravity (m/s\u00b2) rho = 1.225 # Air density (kg/m\u00b3) A = 0.01 # Cross-sectional area (m\u00b2) m = 0.145 # Mass of projectile (kg) (e.g., baseball) # Define equations of motion def equations(t, state, Cd, A, m, rho): x, y, vx, vy = state v = np.sqrt(vx**2 + vy**2) # Speed magnitude drag = (0.5 * Cd * rho * A * v**2) / m # Drag force ax = -drag * (vx / v) # Acceleration in x ay = -g - drag * (vy / v) # Acceleration in y return [vx, vy, ax, ay] # Solve equations using Runge-Kutta def solve_projectile(v0, theta_deg, Cd): theta = np.radians(theta_deg) vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) state0 = [0, 0, vx0, vy0] t_span = (0, 5) t_eval = np.linspace(0, 5, 300) sol = solve_ivp(equations, t_span, state0, t_eval=t_eval, args=(Cd, A, m, rho)) return sol.y[0], sol.y[1] # Return x and y coordinates # Function to update plot dynamically def update_plot(v0, theta_deg, Cd): fig, ax = plt.subplots(figsize=(12, 7.5)) # Create new figure each time ax.set_xlabel('Distance (m)') ax.set_ylabel('Height (m)') ax.set_title('Projectile Motion with Air Resistance') ax.set_xlim(0, 50) # Set fixed axis limits ax.set_ylim(0, 15) ax.grid() x, y = solve_projectile(v0, theta_deg, Cd) # Solve motion equations ax.plot(x, y, label=f'v0={v0} m/s, \u03b8={theta_deg}\u00b0, Cd={Cd}', color='b') ax.legend() plt.show() # Display updated plot # Interactive widgets v0_slider = widgets.FloatSlider(value=20, min=5, max=50, step=1, description='v0 (m/s)') theta_slider = widgets.FloatSlider(value=45, min=0, max=90, step=1, description='Angle (\u00b0)') Cd_slider = widgets.FloatSlider(value=0.47, min=0, max=1.5, step=0.05, description='Cd (Drag)') # Link widgets with update function out = widgets.interactive_output(update_plot, {'v0': v0_slider, 'theta_deg': theta_slider, 'Cd': Cd_slider}) # Display the widgets and plot ui = widgets.VBox([v0_slider, theta_slider, Cd_slider]) display(ui, out)","title":"4. Interactive Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-launch-from-different-heights","text":"We modify our simulation to allow for launch at y\u2080\u22600. This affects the time of flight calculation. Learn more. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # Gravity (m/s\u00b2) rho = 1.225 # Air density (kg/m\u00b3) Cd = 0.47 # Drag coefficient (sphere) A = 0.01 # Cross-sectional area (m\u00b2) m = 0.145 # Mass of projectile (kg) (e.g., baseball) def equations(t, state, Cd, A, m, rho): \"\"\"Differential equations for projectile motion with air resistance.\"\"\" x, y, vx, vy = state v = np.sqrt(vx**2 + vy**2) # Speed drag = (0.5 * Cd * rho * A * v**2) / m # Drag acceleration ax = -drag * (vx / v) # Drag in x-direction ay = -g - drag * (vy / v) # Drag in y-direction return [vx, vy, ax, ay] def solve_projectile_height(v0, theta_deg, y0, Cd=0.47): \"\"\"Solve projectile motion with different initial heights.\"\"\" theta = np.radians(theta_deg) vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) # Initial conditions state0 = [0, y0, vx0, vy0] # Solve sol = solve_ivp(equations, (0, 10), state0, t_eval=np.linspace(0, 10, 500), args=(Cd, A, m, rho)) return sol.t, sol.y[0], sol.y[1] # Example Plot def plot_trajectory(para_list): plt.figure(figsize=(12, 7.5)) for para in para_list: v0, theta_deg, Cd, init_height = para t, x, y = solve_projectile_height(v0, theta_deg, init_height, Cd) plt.plot(x, y, label=f'v0={v0} m/s, \u03b8={theta_deg}\u00b0, Cd={Cd}, y0={init_height}m') plt.xlabel('Distance (m)') plt.ylabel('Height (m)') plt.title('Projectile Motion with Air Resistance') plt.legend() plt.grid() plt.ylim(0) plt.show() # Example: Launch from different height plot_trajectory([(20, 45, 0.47, 3), (20, 45, 0.47, 6), (20, 45, 0.47, 9), (20, 45, 0.47, 12)])","title":"5. Launch from Different Heights"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a fascinating example of a system where damping, restoring forces, and external periodic forcing interplay to create rich dynamic behavior. This system exhibits a variety of phenomena, including resonance, chaos, and quasiperiodicity, making it a valuable subject for studying complex real-world systems such as driven oscillators, climate models, and mechanical structures under periodic stress. By adjusting parameters like damping, external force amplitude, and driving frequency, the system transitions through different behaviors, such as synchronized oscillations, chaotic motion, and resonance phenomena. Understanding these behaviors has significant implications for fields like energy harvesting, vibration isolation, and mechanical resonance. Theoretical Foundation The motion of a forced damped pendulum is governed by the differential equation: \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t)\\] where: \\( \\theta(t) \\) is the angular displacement, \\( b \\) is the damping coefficient, \\( g \\) is the gravitational acceleration, \\( L \\) is the length of the pendulum, \\( A \\) is the amplitude of the external force, \\( \\omega \\) is the driving frequency. Small-Angle Approximation For small angles, we approximate \\( \\sin\\theta \\approx \\theta \\) , reducing the equation to: \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t)\\] This equation describes a forced damped harmonic oscillator with the general solution: \\[\\theta(t) = \\theta_0 e^{-bt/2} \\cos(\\omega t - \\delta)\\] where \\( \\theta_0 \\) and \\( \\delta \\) depend on the system parameters. Resonance Conditions Resonance occurs when the driving frequency \\( \\omega \\) matches the natural frequency: \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] At resonance, the amplitude grows significantly unless limited by damping. Analysis of Dynamics Effects of Parameters Damping coefficient ( \\( b \\) ) : Higher damping reduces oscillation amplitude and affects stability. Driving amplitude ( \\( A \\) ) : Higher values increase oscillation response and can induce chaotic behavior. Driving frequency ( \\( \\omega \\) ) : Near resonance, large oscillations appear, leading to energy amplification. Transition to Chaos Beyond simple oscillations, varying \\( b \\) , \\( A \\) , and \\( \\omega \\) leads to quasiperiodic or chaotic motion. The transition to chaos can be observed using bifurcation diagrams and Poincar\u00e9 sections. These chaotic behaviors arise from the system\u2019s sensitivity to initial conditions, a hallmark of deterministic chaos. Practical Applications Energy Harvesting : Used in piezoelectric devices to convert oscillatory motion into electrical energy. Suspension Bridges : Models forced oscillations under periodic forces, such as wind or traffic-induced vibrations. Oscillating Circuits : Analogous to driven RLC circuits, where voltage replaces angular displacement and current replaces velocity. Biological Rhythms : Similar dynamics appear in human gait patterns and circadian rhythms under external influences. Seismic Engineering : Structures subjected to periodic seismic forcing can be analyzed using pendulum models. Planetary Motion : Certain planetary rotational dynamics exhibit nonlinear oscillatory behavior similar to forced pendulums. Graphical Representations Time Series : Plots of \\( \\theta(t) \\) to observe periodicity or chaos. Learn more. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def forced_damped_pendulum(t, y, b, g, L, A, omega_d): \"\"\"ODE system for a forced damped pendulum.\"\"\" theta, omega = y # omega represents angular velocity (dtheta/dt) dtheta_dt = omega domega_dt = -b * omega - (g/L) * np.sin(theta) + A * np.cos(omega_d * t) # Corrected force term return [dtheta_dt, domega_dt] # Parameters g = 9.81 # Gravity (m/s^2) L = 1.0 # Length of pendulum (m) y0 = [np.pi / 4, 0] # Initial angle = 45 degrees, initial velocity = 0 # Different parameter sets to compare cases = [ {\"b\": 0.2, \"A\": 1.0, \"omega_d\": 1.5, \"label\": \"b=0.2, A=1.0, \u03c9=1.5\"}, {\"b\": 0.5, \"A\": 1.2, \"omega_d\": 2.0, \"label\": \"b=0.5, A=1.2, \u03c9=2.0\"}, {\"b\": 0.8, \"A\": 1.5, \"omega_d\": 2.5, \"label\": \"b=0.8, A=1.5, \u03c9=2.5\"}, ] # Time range t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 1000) plt.figure(figsize=(12, 7.5)) # Solve and plot for different cases for case in cases: sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(case[\"b\"], g, L, case[\"A\"], case[\"omega_d\"])) plt.plot(sol.t, sol.y[0], label=case[\"label\"]) # Formatting the plot plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.title('Forced Damped Pendulum Motion (Multiple Instances)') plt.legend() plt.grid(True) plt.show() Phase Portraits : \\( \\theta \\) vs. \\( \\frac{d\\theta}{dt} \\) to analyze system stability and attractors. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def forced_damped_pendulum(t, y, b, g, L, A, omega): \"\"\"ODE system for a forced damped pendulum.\"\"\" theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g/L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters g = 9.81 # Gravity (m/s\u00b2) L = 1.0 # Length of pendulum (m) y0 = [np.pi / 4, 0] # Initial angle = 45 degrees, initial velocity = 0 # Different parameter sets to compare cases = [ {\"b\": 0.2, \"A\": 1.0, \"omega\": 1.5, \"color\": \"r\", \"label\": \"b=0.2, A=1.0, \u03c9=1.5\"}, {\"b\": 0.5, \"A\": 1.2, \"omega\": 2.0, \"color\": \"b\", \"label\": \"b=0.5, A=1.2, \u03c9=2.0\"}, {\"b\": 0.8, \"A\": 1.5, \"omega\": 2.5, \"color\": \"g\", \"label\": \"b=0.8, A=1.5, \u03c9=2.5\"}, ] # Time range t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 1000) plt.figure(figsize=(12, 7.5)) # Solve and plot for different cases for case in cases: sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(case[\"b\"], g, L, case[\"A\"], case[\"omega\"])) plt.plot(sol.y[0], sol.y[1], color=case[\"color\"], label=case[\"label\"]) # Formatting plt.xlabel('Theta (angle)') plt.ylabel('Angular Velocity') plt.title('Phase Portrait of Forced Damped Pendulum') plt.legend() plt.grid(True) plt.show() Poincar\u00e9 Sections : Used to detect chaotic behavior by sampling system states at discrete time intervals. Bifurcation Diagrams : Show transitions to complex motion as system parameters are varied, revealing period-doubling cascades leading to chaos. Lyapunov Exponents : Used to quantify chaos by measuring the rate of separation of nearby trajectories. Conclusion This study of the forced damped pendulum provides insight into nonlinear dynamics, resonance, and chaos, with applications in physics and engineering. By using numerical simulations, we can explore a range of behaviors from simple periodic motion to chaotic dynamics, offering deeper understanding and practical implications in various scientific domains. The forced damped pendulum serves as a fundamental model for diverse physical systems, reinforcing the significance of nonlinear dynamics in both theoretical and applied research.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a fascinating example of a system where damping, restoring forces, and external periodic forcing interplay to create rich dynamic behavior. This system exhibits a variety of phenomena, including resonance, chaos, and quasiperiodicity, making it a valuable subject for studying complex real-world systems such as driven oscillators, climate models, and mechanical structures under periodic stress. By adjusting parameters like damping, external force amplitude, and driving frequency, the system transitions through different behaviors, such as synchronized oscillations, chaotic motion, and resonance phenomena. Understanding these behaviors has significant implications for fields like energy harvesting, vibration isolation, and mechanical resonance.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#theoretical-foundation","text":"The motion of a forced damped pendulum is governed by the differential equation: \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t)\\] where: \\( \\theta(t) \\) is the angular displacement, \\( b \\) is the damping coefficient, \\( g \\) is the gravitational acceleration, \\( L \\) is the length of the pendulum, \\( A \\) is the amplitude of the external force, \\( \\omega \\) is the driving frequency.","title":"Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small angles, we approximate \\( \\sin\\theta \\approx \\theta \\) , reducing the equation to: \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t)\\] This equation describes a forced damped harmonic oscillator with the general solution: \\[\\theta(t) = \\theta_0 e^{-bt/2} \\cos(\\omega t - \\delta)\\] where \\( \\theta_0 \\) and \\( \\delta \\) depend on the system parameters.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","text":"Resonance occurs when the driving frequency \\( \\omega \\) matches the natural frequency: \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] At resonance, the amplitude grows significantly unless limited by damping.","title":"Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#analysis-of-dynamics","text":"","title":"Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effects-of-parameters","text":"Damping coefficient ( \\( b \\) ) : Higher damping reduces oscillation amplitude and affects stability. Driving amplitude ( \\( A \\) ) : Higher values increase oscillation response and can induce chaotic behavior. Driving frequency ( \\( \\omega \\) ) : Near resonance, large oscillations appear, leading to energy amplification.","title":"Effects of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-to-chaos","text":"Beyond simple oscillations, varying \\( b \\) , \\( A \\) , and \\( \\omega \\) leads to quasiperiodic or chaotic motion. The transition to chaos can be observed using bifurcation diagrams and Poincar\u00e9 sections. These chaotic behaviors arise from the system\u2019s sensitivity to initial conditions, a hallmark of deterministic chaos.","title":"Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#practical-applications","text":"Energy Harvesting : Used in piezoelectric devices to convert oscillatory motion into electrical energy. Suspension Bridges : Models forced oscillations under periodic forces, such as wind or traffic-induced vibrations. Oscillating Circuits : Analogous to driven RLC circuits, where voltage replaces angular displacement and current replaces velocity. Biological Rhythms : Similar dynamics appear in human gait patterns and circadian rhythms under external influences. Seismic Engineering : Structures subjected to periodic seismic forcing can be analyzed using pendulum models. Planetary Motion : Certain planetary rotational dynamics exhibit nonlinear oscillatory behavior similar to forced pendulums.","title":"Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#graphical-representations","text":"Time Series : Plots of \\( \\theta(t) \\) to observe periodicity or chaos. Learn more. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def forced_damped_pendulum(t, y, b, g, L, A, omega_d): \"\"\"ODE system for a forced damped pendulum.\"\"\" theta, omega = y # omega represents angular velocity (dtheta/dt) dtheta_dt = omega domega_dt = -b * omega - (g/L) * np.sin(theta) + A * np.cos(omega_d * t) # Corrected force term return [dtheta_dt, domega_dt] # Parameters g = 9.81 # Gravity (m/s^2) L = 1.0 # Length of pendulum (m) y0 = [np.pi / 4, 0] # Initial angle = 45 degrees, initial velocity = 0 # Different parameter sets to compare cases = [ {\"b\": 0.2, \"A\": 1.0, \"omega_d\": 1.5, \"label\": \"b=0.2, A=1.0, \u03c9=1.5\"}, {\"b\": 0.5, \"A\": 1.2, \"omega_d\": 2.0, \"label\": \"b=0.5, A=1.2, \u03c9=2.0\"}, {\"b\": 0.8, \"A\": 1.5, \"omega_d\": 2.5, \"label\": \"b=0.8, A=1.5, \u03c9=2.5\"}, ] # Time range t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 1000) plt.figure(figsize=(12, 7.5)) # Solve and plot for different cases for case in cases: sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(case[\"b\"], g, L, case[\"A\"], case[\"omega_d\"])) plt.plot(sol.t, sol.y[0], label=case[\"label\"]) # Formatting the plot plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.title('Forced Damped Pendulum Motion (Multiple Instances)') plt.legend() plt.grid(True) plt.show() Phase Portraits : \\( \\theta \\) vs. \\( \\frac{d\\theta}{dt} \\) to analyze system stability and attractors. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def forced_damped_pendulum(t, y, b, g, L, A, omega): \"\"\"ODE system for a forced damped pendulum.\"\"\" theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g/L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters g = 9.81 # Gravity (m/s\u00b2) L = 1.0 # Length of pendulum (m) y0 = [np.pi / 4, 0] # Initial angle = 45 degrees, initial velocity = 0 # Different parameter sets to compare cases = [ {\"b\": 0.2, \"A\": 1.0, \"omega\": 1.5, \"color\": \"r\", \"label\": \"b=0.2, A=1.0, \u03c9=1.5\"}, {\"b\": 0.5, \"A\": 1.2, \"omega\": 2.0, \"color\": \"b\", \"label\": \"b=0.5, A=1.2, \u03c9=2.0\"}, {\"b\": 0.8, \"A\": 1.5, \"omega\": 2.5, \"color\": \"g\", \"label\": \"b=0.8, A=1.5, \u03c9=2.5\"}, ] # Time range t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 1000) plt.figure(figsize=(12, 7.5)) # Solve and plot for different cases for case in cases: sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(case[\"b\"], g, L, case[\"A\"], case[\"omega\"])) plt.plot(sol.y[0], sol.y[1], color=case[\"color\"], label=case[\"label\"]) # Formatting plt.xlabel('Theta (angle)') plt.ylabel('Angular Velocity') plt.title('Phase Portrait of Forced Damped Pendulum') plt.legend() plt.grid(True) plt.show() Poincar\u00e9 Sections : Used to detect chaotic behavior by sampling system states at discrete time intervals. Bifurcation Diagrams : Show transitions to complex motion as system parameters are varied, revealing period-doubling cascades leading to chaos. Lyapunov Exponents : Used to quantify chaos by measuring the rate of separation of nearby trajectories.","title":"Graphical Representations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"This study of the forced damped pendulum provides insight into nonlinear dynamics, resonance, and chaos, with applications in physics and engineering. By using numerical simulations, we can explore a range of behaviors from simple periodic motion to chaotic dynamics, offering deeper understanding and practical implications in various scientific domains. The forced damped pendulum serves as a fundamental model for diverse physical systems, reinforcing the significance of nonlinear dynamics in both theoretical and applied research.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius: Kepler's Third Law Introduction The study of planetary motion has played a significant role in the development of astronomy and physics. Before Newton's laws of motion, astronomers relied on empirical observations to describe the movement of celestial bodies. One of the most important contributions in this field was made by Johannes Kepler , who formulated three laws of planetary motion. Among these, Kepler\u2019s Third Law provides a crucial relationship between the orbital period and orbital radius of a planet: \\[ T^2 \\propto r^3 \\] This means that if we know the distance of a celestial object from the central body it orbits, we can predict its orbital period. This law applies to any object in a stable orbit , including planets, moons, and artificial satellites. Mathematically, the law is written as: \\[ T^2 = \\frac{4\\pi^2 r^3}{GM} \\] where: Symbol Description \\(T\\) Orbital period (seconds) \\(r\\) Orbital radius (meters) \\(G\\) Gravitational constant ( \\(6.67430 \\times 10^{-11} \\, m^3 kg^{-1} s^{-2}\\) ) \\(M\\) Mass of the central body (kg) This equation reveals that larger orbital radii correspond to longer orbital periods , governing planetary motion in the Solar System and beyond. Historical Background In 1609, Johannes Kepler formulated three laws of planetary motion based on observational data collected by Tycho Brahe . These laws describe how planets move in elliptical orbits, how their speed varies, and the relationship between their orbital period and distance from the Sun. Kepler's Law Description First Law (Law of Ellipses) Planets move in elliptical orbits with the Sun at one focus. Second Law (Law of Equal Areas) A planet sweeps out equal areas in equal time intervals , meaning it moves faster when closer to the Sun and slower when farther. Third Law (Law of Harmonies) The square of a planet's orbital period is proportional to the cube of its orbital radius . Kepler's laws were originally based on empirical observations , but in 1687, Isaac Newton derived them using his Law of Universal Gravitation , proving that these laws arise naturally from gravitational forces. Derivation of Kepler's Third Law Newton\u2019s version of Kepler\u2019s Third Law can be derived using Newton\u2019s Law of Universal Gravitation and centripetal force . The gravitational force acting on a planet of mass \\(m\\) is: $$ F_g = \\frac{GMm}{r^2} $$ The centripetal force required for circular motion is: $$ F_c = \\frac{m v^2}{r} $$ Since the gravitational force provides the necessary centripetal force: $$ \\frac{GMm}{r^2} = \\frac{m v^2}{r} $$ Expressing velocity in terms of the orbital period: $$ v = \\frac{2\\pi r}{T} $$ Substituting this into the equation: $$ \\frac{GMm}{r^2} = \\frac{m (2\\pi r / T)^2}{r} $$ Simplifying: $$ GM = \\frac{4\\pi^2 r^3}{T^2} $$ Solving for \\(T^2\\) : $$ T^2 = \\frac{4\\pi^2 r^3}{GM} $$ This is the modern Newtonian form of Kepler\u2019s Third Law , showing that the orbital period squared is proportional to the orbital radius cubed . Applications in Astronomy Kepler\u2019s Third Law has several applications in astronomy and space exploration: 1. Determining Planetary Masses By measuring the orbital period and distance of a planet\u2019s moon, we can calculate the planet\u2019s mass using: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] For example, the mass of Earth can be determined by analyzing the Moon\u2019s orbit. 2. Satellite Motion Engineers use Kepler\u2019s Third Law to design satellites and space stations. By selecting the appropriate altitude, they can ensure stable orbits for satellites such as GPS and communication satellites. Satellite Orbital Radius (km) Orbital Period (hours) GPS 26,600 12 Geostationary 42,164 24 Hubble Space Telescope 6,978 1.5 3. Exoplanet Discovery Astronomers detect exoplanets by measuring the dimming of stars due to planetary transits. Using Kepler\u2019s Third Law, they estimate the planet\u2019s distance from its star and deduce whether it lies in the habitable zone . Exoplanet Orbital Radius (AU) Orbital Period (Days) Kepler-22b 0.85 290 Proxima Centauri b 0.05 11.2 51 Pegasi b 0.05 4.2 4. Comparing Different Orbital Systems Kepler\u2019s Law helps compare planetary orbits in different star systems and allows astronomers to analyze binary star systems. The Solar System and Kepler\u2019s Law The following table lists the orbital radius and period of major planets in the Solar System, illustrating Kepler\u2019s Third Law. Planet Orbital Radius (AU) Orbital Period (Years) \\(T^2\\) \\(r^3\\) Mercury 0.39 0.24 0.0576 0.0593 Venus 0.72 0.62 0.3844 0.3732 Earth 1.00 1.00 1.0000 1.0000 Mars 1.52 1.88 3.5344 3.5123 Jupiter 5.20 11.86 140.6596 140.6080 Saturn 9.58 29.46 867.0916 881.1824 The values for \\(T^2\\) and \\(r^3\\) confirm the proportional relationship predicted by Kepler's Third Law . Conclusion Kepler\u2019s Third Law provides a crucial link between gravity and orbital motion . It extends beyond planets and applies to moons, artificial satellites, and even binary star systems . By analyzing Kepler\u2019s Third Law, astronomers can determine planetary masses, satellite trajectories, and the structure of distant star systems. Implementation in Python The following Python script computes orbital periods for different celestial bodies and visualizes the relationship. Learn more. import numpy as np import matplotlib.pyplot as plt def keplers_third_law(G, M, radii): \"\"\" Computes the orbital periods based on Kepler's Third Law: T^2 = (4\u03c0^2 * r^3) / (G * M) Parameters: G : float : Gravitational constant (m^3 kg^-1 s^-2) M : float : Mass of the central body (kg) radii : array : Orbital radii (m) Returns: periods : array : Orbital periods (s) \"\"\" return np.sqrt((4 * np.pi**2 * radii**3) / (G * M)) # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) M_sun = 1.989e30 # Mass of Sun (kg) # Orbital radii (in meters) radii = np.array([ 3.844e8, # Moon around Earth 1.496e11, # Earth around Sun 2.279e11, # Mars around Sun 7.785e11 # Jupiter around Sun ]) # Compute periods periods_earth = keplers_third_law(G, M_earth, radii[:1]) # Moon orbiting Earth periods_sun = keplers_third_law(G, M_sun, radii[1:]) # Planets orbiting the Sun # Convert seconds to days periods_earth_days = periods_earth / (60 * 60 * 24) periods_sun_days = periods_sun / (60 * 60 * 24) # Print computed values in table format print(f\"{'Celestial Body':<20}{'Orbital Radius (m)':<25}{'Orbital Period (days)':<25}\") print(\"-\" * 70) celestial_bodies = [\"Moon (around Earth)\", \"Earth (around Sun)\", \"Mars (around Sun)\", \"Jupiter (around Sun)\"] all_periods = np.concatenate([periods_earth_days, periods_sun_days]) for i in range(len(radii)): print(f\"{celestial_bodies[i]:<20}{radii[i]:<25.3e}{all_periods[i]:<25.3f}\") # Plot results radii_plot = np.linspace(1e7, 3e12, 100) # Extended range of radii periods_plot_earth = keplers_third_law(G, M_earth, radii_plot) periods_plot_sun = keplers_third_law(G, M_sun, radii_plot) plt.figure(figsize=(12, 7.5)) plt.loglog(radii_plot, periods_plot_earth / (60 * 60 * 24), label='Moon around Earth', linestyle='dashed') plt.loglog(radii_plot, periods_plot_sun / (60 * 60 * 24), label='Planets around Sun', linestyle='solid') plt.scatter(radii, all_periods, color='red', zorder=3, label='Real Data') # Add annotations for clarity for i, txt in enumerate(celestial_bodies): plt.annotate(txt, (radii[i], all_periods[i]), textcoords=\"offset points\", xytext=(10,-10), ha='left') # Improve axis labels plt.xlabel('Orbital Radius (m)', fontsize=12) plt.ylabel('Orbital Period (days)', fontsize=12) plt.title(\"Kepler's Third Law: Period vs Radius\", fontsize=14) plt.legend() plt.grid(True, which='both', linestyle='--', linewidth=0.5) plt.show()","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius-keplers-third-law","text":"","title":"Orbital Period and Orbital Radius: Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#introduction","text":"The study of planetary motion has played a significant role in the development of astronomy and physics. Before Newton's laws of motion, astronomers relied on empirical observations to describe the movement of celestial bodies. One of the most important contributions in this field was made by Johannes Kepler , who formulated three laws of planetary motion. Among these, Kepler\u2019s Third Law provides a crucial relationship between the orbital period and orbital radius of a planet: \\[ T^2 \\propto r^3 \\] This means that if we know the distance of a celestial object from the central body it orbits, we can predict its orbital period. This law applies to any object in a stable orbit , including planets, moons, and artificial satellites. Mathematically, the law is written as: \\[ T^2 = \\frac{4\\pi^2 r^3}{GM} \\] where: Symbol Description \\(T\\) Orbital period (seconds) \\(r\\) Orbital radius (meters) \\(G\\) Gravitational constant ( \\(6.67430 \\times 10^{-11} \\, m^3 kg^{-1} s^{-2}\\) ) \\(M\\) Mass of the central body (kg) This equation reveals that larger orbital radii correspond to longer orbital periods , governing planetary motion in the Solar System and beyond.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_1/#historical-background","text":"In 1609, Johannes Kepler formulated three laws of planetary motion based on observational data collected by Tycho Brahe . These laws describe how planets move in elliptical orbits, how their speed varies, and the relationship between their orbital period and distance from the Sun. Kepler's Law Description First Law (Law of Ellipses) Planets move in elliptical orbits with the Sun at one focus. Second Law (Law of Equal Areas) A planet sweeps out equal areas in equal time intervals , meaning it moves faster when closer to the Sun and slower when farther. Third Law (Law of Harmonies) The square of a planet's orbital period is proportional to the cube of its orbital radius . Kepler's laws were originally based on empirical observations , but in 1687, Isaac Newton derived them using his Law of Universal Gravitation , proving that these laws arise naturally from gravitational forces.","title":"Historical Background"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law","text":"Newton\u2019s version of Kepler\u2019s Third Law can be derived using Newton\u2019s Law of Universal Gravitation and centripetal force . The gravitational force acting on a planet of mass \\(m\\) is: $$ F_g = \\frac{GMm}{r^2} $$ The centripetal force required for circular motion is: $$ F_c = \\frac{m v^2}{r} $$ Since the gravitational force provides the necessary centripetal force: $$ \\frac{GMm}{r^2} = \\frac{m v^2}{r} $$ Expressing velocity in terms of the orbital period: $$ v = \\frac{2\\pi r}{T} $$ Substituting this into the equation: $$ \\frac{GMm}{r^2} = \\frac{m (2\\pi r / T)^2}{r} $$ Simplifying: $$ GM = \\frac{4\\pi^2 r^3}{T^2} $$ Solving for \\(T^2\\) : $$ T^2 = \\frac{4\\pi^2 r^3}{GM} $$ This is the modern Newtonian form of Kepler\u2019s Third Law , showing that the orbital period squared is proportional to the orbital radius cubed .","title":"Derivation of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#applications-in-astronomy","text":"Kepler\u2019s Third Law has several applications in astronomy and space exploration:","title":"Applications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-determining-planetary-masses","text":"By measuring the orbital period and distance of a planet\u2019s moon, we can calculate the planet\u2019s mass using: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] For example, the mass of Earth can be determined by analyzing the Moon\u2019s orbit.","title":"1. Determining Planetary Masses"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-satellite-motion","text":"Engineers use Kepler\u2019s Third Law to design satellites and space stations. By selecting the appropriate altitude, they can ensure stable orbits for satellites such as GPS and communication satellites. Satellite Orbital Radius (km) Orbital Period (hours) GPS 26,600 12 Geostationary 42,164 24 Hubble Space Telescope 6,978 1.5","title":"2. Satellite Motion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-exoplanet-discovery","text":"Astronomers detect exoplanets by measuring the dimming of stars due to planetary transits. Using Kepler\u2019s Third Law, they estimate the planet\u2019s distance from its star and deduce whether it lies in the habitable zone . Exoplanet Orbital Radius (AU) Orbital Period (Days) Kepler-22b 0.85 290 Proxima Centauri b 0.05 11.2 51 Pegasi b 0.05 4.2","title":"3. Exoplanet Discovery"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-comparing-different-orbital-systems","text":"Kepler\u2019s Law helps compare planetary orbits in different star systems and allows astronomers to analyze binary star systems.","title":"4. Comparing Different Orbital Systems"},{"location":"1%20Physics/2%20Gravity/Problem_1/#the-solar-system-and-keplers-law","text":"The following table lists the orbital radius and period of major planets in the Solar System, illustrating Kepler\u2019s Third Law. Planet Orbital Radius (AU) Orbital Period (Years) \\(T^2\\) \\(r^3\\) Mercury 0.39 0.24 0.0576 0.0593 Venus 0.72 0.62 0.3844 0.3732 Earth 1.00 1.00 1.0000 1.0000 Mars 1.52 1.88 3.5344 3.5123 Jupiter 5.20 11.86 140.6596 140.6080 Saturn 9.58 29.46 867.0916 881.1824 The values for \\(T^2\\) and \\(r^3\\) confirm the proportional relationship predicted by Kepler's Third Law .","title":"The Solar System and Kepler\u2019s Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler\u2019s Third Law provides a crucial link between gravity and orbital motion . It extends beyond planets and applies to moons, artificial satellites, and even binary star systems . By analyzing Kepler\u2019s Third Law, astronomers can determine planetary masses, satellite trajectories, and the structure of distant star systems.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implementation-in-python","text":"The following Python script computes orbital periods for different celestial bodies and visualizes the relationship. Learn more. import numpy as np import matplotlib.pyplot as plt def keplers_third_law(G, M, radii): \"\"\" Computes the orbital periods based on Kepler's Third Law: T^2 = (4\u03c0^2 * r^3) / (G * M) Parameters: G : float : Gravitational constant (m^3 kg^-1 s^-2) M : float : Mass of the central body (kg) radii : array : Orbital radii (m) Returns: periods : array : Orbital periods (s) \"\"\" return np.sqrt((4 * np.pi**2 * radii**3) / (G * M)) # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) M_sun = 1.989e30 # Mass of Sun (kg) # Orbital radii (in meters) radii = np.array([ 3.844e8, # Moon around Earth 1.496e11, # Earth around Sun 2.279e11, # Mars around Sun 7.785e11 # Jupiter around Sun ]) # Compute periods periods_earth = keplers_third_law(G, M_earth, radii[:1]) # Moon orbiting Earth periods_sun = keplers_third_law(G, M_sun, radii[1:]) # Planets orbiting the Sun # Convert seconds to days periods_earth_days = periods_earth / (60 * 60 * 24) periods_sun_days = periods_sun / (60 * 60 * 24) # Print computed values in table format print(f\"{'Celestial Body':<20}{'Orbital Radius (m)':<25}{'Orbital Period (days)':<25}\") print(\"-\" * 70) celestial_bodies = [\"Moon (around Earth)\", \"Earth (around Sun)\", \"Mars (around Sun)\", \"Jupiter (around Sun)\"] all_periods = np.concatenate([periods_earth_days, periods_sun_days]) for i in range(len(radii)): print(f\"{celestial_bodies[i]:<20}{radii[i]:<25.3e}{all_periods[i]:<25.3f}\") # Plot results radii_plot = np.linspace(1e7, 3e12, 100) # Extended range of radii periods_plot_earth = keplers_third_law(G, M_earth, radii_plot) periods_plot_sun = keplers_third_law(G, M_sun, radii_plot) plt.figure(figsize=(12, 7.5)) plt.loglog(radii_plot, periods_plot_earth / (60 * 60 * 24), label='Moon around Earth', linestyle='dashed') plt.loglog(radii_plot, periods_plot_sun / (60 * 60 * 24), label='Planets around Sun', linestyle='solid') plt.scatter(radii, all_periods, color='red', zorder=3, label='Real Data') # Add annotations for clarity for i, txt in enumerate(celestial_bodies): plt.annotate(txt, (radii[i], all_periods[i]), textcoords=\"offset points\", xytext=(10,-10), ha='left') # Improve axis labels plt.xlabel('Orbital Radius (m)', fontsize=12) plt.ylabel('Orbital Period (days)', fontsize=12) plt.title(\"Kepler's Third Law: Period vs Radius\", fontsize=14) plt.legend() plt.grid(True, which='both', linestyle='--', linewidth=0.5) plt.show()","title":"Implementation in Python"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Introduction The concept of escape velocity is a fundamental idea in orbital mechanics, representing the minimum velocity required for an object to break free from a celestial body's gravitational pull without further propulsion. Alongside this, the cosmic velocities define different thresholds that mark the boundaries for various stages of escape and orbiting in a gravitational system. In this document, we explore the first, second, and third cosmic velocities , the equations governing them, and their importance in space exploration. These velocities provide the necessary guidelines for launching satellites, interplanetary missions, and even future interstellar travel. The Three Cosmic Velocities First Cosmic Velocity (Orbital Velocity) : The speed required for an object to stay in a stable orbit around a celestial body. This is the velocity at which an object must travel to balance the gravitational pull with the centrifugal force. Second Cosmic Velocity (Escape Velocity) : The speed needed for an object to escape a celestial body's gravitational influence. This velocity ensures that the object can move away from the body indefinitely, without falling back. Third Cosmic Velocity (Solar Escape Velocity) : The velocity required for an object to escape the gravitational influence of the Sun (or another central star) and enter interstellar space. Derivation of Cosmic Velocities 1. First Cosmic Velocity (Orbital Velocity) The first cosmic velocity is the orbital velocity that an object must achieve to stay in a circular orbit around a celestial body. This can be derived by equating the gravitational force ( \\(F_{\\text{gravity}}\\) ) to the centripetal force ( \\(F_{\\text{centripetal}}\\) ) acting on the object. The gravitational force is: \\[ F_{\\text{gravity}} = \\frac{GMm}{r^2} \\] The centripetal force required for circular motion is: \\[ F_{\\text{centripetal}} = \\frac{mv^2}{r} \\] Where: \\(G\\) is the gravitational constant, \\(M\\) is the mass of the celestial body, \\(m\\) is the mass of the orbiting object, \\(r\\) is the orbital radius (distance from the center of the celestial body), \\(v\\) is the orbital velocity. Equating the two forces: \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] After simplifying, we find the formula for the first cosmic velocity : \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] Where: \\(v_1\\) is the first cosmic velocity, \\(M\\) is the mass of the central celestial body, \\(r\\) is the orbital radius (distance from the center of the celestial body). 2. Second Cosmic Velocity (Escape Velocity) The second cosmic velocity is the escape velocity required to break free from the gravitational pull of a celestial body. This is derived from the energy principle, where the total mechanical energy of the object (kinetic energy + potential energy) must be zero for the object to escape. The gravitational potential energy is given by: \\[ E_{\\text{potential}} = -\\frac{GMm}{r} \\] The kinetic energy required for escape is: \\[ E_{\\text{kinetic}} = \\frac{1}{2}mv^2 \\] For escape, the total energy should be zero, so: \\[ \\frac{1}{2}mv_2^2 = \\frac{GMm}{r} \\] Solving for \\(v_2\\) , the escape velocity : \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] Where: \\(v_2\\) is the second cosmic velocity, \\(M\\) is the mass of the celestial body, \\(r\\) is the radial distance from the center of the body. 3. Third Cosmic Velocity (Solar Escape Velocity) The third cosmic velocity is the velocity needed for an object to escape the gravitational influence of the Sun (or any other central star) and travel into interstellar space. The escape velocity from the Sun can be derived similarly to the second cosmic velocity, but with the Sun's mass as the central body. The third cosmic velocity is given by: \\[ v_3 = \\sqrt{\\frac{2GM_{\\text{sun}}}{r}} \\] Where: \\(v_3\\) is the third cosmic velocity, \\(M_{\\text{sun}}\\) is the mass of the Sun (or the mass of another central star), \\(r\\) is the distance from the Sun (or the central star). Cosmic Velocities for Different Celestial Bodies Table 1: Velocities for Earth, Mars, and Jupiter The following table summarizes the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. Celestial Body Orbital Radius (m) First Cosmic Velocity (v\u2081) [m/s] Second Cosmic Velocity (v\u2082) [m/s] Third Cosmic Velocity (v\u2083) [m/s] Earth 6.371 \u00d7 10\u2076 7.12 \u00d7 10\u00b3 1.12 \u00d7 10\u2074 6.26 \u00d7 10\u2074 Mars 3.396 \u00d7 10\u2076 5.40 \u00d7 10\u00b3 9.51 \u00d7 10\u00b3 N/A Jupiter 6.991 \u00d7 10\u2077 1.29 \u00d7 10\u2074 1.83 \u00d7 10\u2074 N/A Python Code for Calculating and Visualizing Velocities Below is the Python code that calculates the first, second, and third cosmic velocities for various celestial bodies, including Earth, Mars, and Jupiter. It also visualizes these velocities using a bar chart. Learn more. import numpy as np import matplotlib.pyplot as plt def first_cosmic_velocity(G, M, r): \"\"\" Calculates the first cosmic velocity (orbital velocity). Parameters: G : float : Gravitational constant (m^3 kg^-1 s^-2) M : float : Mass of the celestial body (kg) r : float : Orbital radius (m) Returns: float : First cosmic velocity (m/s) \"\"\" return np.sqrt(G * M / r) def second_cosmic_velocity(G, M, r): \"\"\" Calculates the second cosmic velocity (escape velocity). Parameters: G : float : Gravitational constant (m^3 kg^-1 s^-2) M : float : Mass of the celestial body (kg) r : float : Orbital radius (m) Returns: float : Second cosmic velocity (m/s) \"\"\" return np.sqrt(2 * G * M / r) def third_cosmic_velocity(G, M_sun, r): \"\"\" Calculates the third cosmic velocity (velocity to escape the solar system). Parameters: G : float : Gravitational constant (m^3 kg^-1 s^-2) M_sun : float : Mass of the Sun (kg) r : float : Distance from the Sun (m) Returns: float : Third cosmic velocity (m/s) \"\"\" return np.sqrt(2 * G * M_sun / r) # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) M_mars = 6.4171e23 # Mass of Mars (kg) M_jupiter = 1.8982e27 # Mass of Jupiter (kg) M_sun = 1.989e30 # Mass of Sun (kg) # Radii (in meters) radii_earth = 6.371e6 # Radius of Earth (m) radii_mars = 3.396e6 # Radius of Mars (m) radii_jupiter = 6.991e7 # Radius of Jupiter (m) distance_sun_earth = 1.496e11 # Distance from Earth to Sun (m) # Compute cosmic velocities v1_earth = first_cosmic_velocity(G, M_earth, radii_earth) v2_earth = second_cosmic_velocity(G, M_earth, radii_earth) v3_earth = third_cosmic_velocity(G, M_sun, distance_sun_earth) v1_mars = first_cosmic_velocity(G, M_mars, radii_mars) v2_mars = second_cosmic_velocity(G, M_mars, radii_mars) v3_mars = third_cosmic_velocity(G, M_sun, distance_sun_earth) # Mars's escape from Sun v1_jupiter = first_cosmic_velocity(G, M_jupiter, radii_jupiter) v2_jupiter = second_cosmic_velocity(G, M_jupiter, radii_jupiter) v3_jupiter = third_cosmic_velocity(G, M_sun, distance_sun_earth) # Jupiter's escape from Sun # Output the velocities for each body print(f\"{'Celestial Body':<20}{'v1 (Orbital Velocity) [m/s]':<30}{'v2 (Escape Velocity) [m/s]':<30}{'v3 (Solar Escape Velocity) [m/s]':<30}\") print(\"-\" * 110) bodies = [\"Earth\", \"Mars\", \"Jupiter\"] velocities = [ (v1_earth, v2_earth, v3_earth), (v1_mars, v2_mars, v3_mars), (v1_jupiter, v2_jupiter, v3_jupiter) ] for i, body in enumerate(bodies): v3_val = velocities[i][2] if velocities[i][2] else \"N/A\" print(f\"{body:<20}{velocities[i][0]:<30.2f}{velocities[i][1]:<30.2f}{v3_val:<30}\") # Plot the velocities labels = [\"Orbital Velocity (v1)\", \"Escape Velocity (v2)\", \"Solar Escape Velocity (v3)\"] # Prepare data for plotting velocities_data = np.array([[ velocities[0][0], velocities[0][1], velocities[0][2]], [velocities[1][0], velocities[1][1], velocities[1][2]], [velocities[2][0], velocities[2][1], velocities[2][2]] ]) fig, ax = plt.subplots(figsize=(12, 7.5)) bar_width = 0.25 index = np.arange(len(bodies)) # Plot the bars bar1 = ax.bar(index - bar_width, velocities_data[:, 0], bar_width, label=labels[0]) bar2 = ax.bar(index, velocities_data[:, 1], bar_width, label=labels[1]) bar3 = ax.bar(index + bar_width, velocities_data[:, 2], bar_width, label=labels[2]) ax.set_xlabel('Celestial Bodies') ax.set_ylabel('Velocity (m/s)') ax.set_title('Cosmic Velocities for Different Celestial Bodies') ax.set_xticks(index) ax.set_xticklabels(bodies) ax.legend() plt.tight_layout() plt.show()","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#introduction","text":"The concept of escape velocity is a fundamental idea in orbital mechanics, representing the minimum velocity required for an object to break free from a celestial body's gravitational pull without further propulsion. Alongside this, the cosmic velocities define different thresholds that mark the boundaries for various stages of escape and orbiting in a gravitational system. In this document, we explore the first, second, and third cosmic velocities , the equations governing them, and their importance in space exploration. These velocities provide the necessary guidelines for launching satellites, interplanetary missions, and even future interstellar travel.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#the-three-cosmic-velocities","text":"First Cosmic Velocity (Orbital Velocity) : The speed required for an object to stay in a stable orbit around a celestial body. This is the velocity at which an object must travel to balance the gravitational pull with the centrifugal force. Second Cosmic Velocity (Escape Velocity) : The speed needed for an object to escape a celestial body's gravitational influence. This velocity ensures that the object can move away from the body indefinitely, without falling back. Third Cosmic Velocity (Solar Escape Velocity) : The velocity required for an object to escape the gravitational influence of the Sun (or another central star) and enter interstellar space.","title":"The Three Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#derivation-of-cosmic-velocities","text":"","title":"Derivation of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity is the orbital velocity that an object must achieve to stay in a circular orbit around a celestial body. This can be derived by equating the gravitational force ( \\(F_{\\text{gravity}}\\) ) to the centripetal force ( \\(F_{\\text{centripetal}}\\) ) acting on the object. The gravitational force is: \\[ F_{\\text{gravity}} = \\frac{GMm}{r^2} \\] The centripetal force required for circular motion is: \\[ F_{\\text{centripetal}} = \\frac{mv^2}{r} \\] Where: \\(G\\) is the gravitational constant, \\(M\\) is the mass of the celestial body, \\(m\\) is the mass of the orbiting object, \\(r\\) is the orbital radius (distance from the center of the celestial body), \\(v\\) is the orbital velocity. Equating the two forces: \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] After simplifying, we find the formula for the first cosmic velocity : \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] Where: \\(v_1\\) is the first cosmic velocity, \\(M\\) is the mass of the central celestial body, \\(r\\) is the orbital radius (distance from the center of the celestial body).","title":"1. First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity","text":"The second cosmic velocity is the escape velocity required to break free from the gravitational pull of a celestial body. This is derived from the energy principle, where the total mechanical energy of the object (kinetic energy + potential energy) must be zero for the object to escape. The gravitational potential energy is given by: \\[ E_{\\text{potential}} = -\\frac{GMm}{r} \\] The kinetic energy required for escape is: \\[ E_{\\text{kinetic}} = \\frac{1}{2}mv^2 \\] For escape, the total energy should be zero, so: \\[ \\frac{1}{2}mv_2^2 = \\frac{GMm}{r} \\] Solving for \\(v_2\\) , the escape velocity : \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] Where: \\(v_2\\) is the second cosmic velocity, \\(M\\) is the mass of the celestial body, \\(r\\) is the radial distance from the center of the body.","title":"2. Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-solar-escape-velocity","text":"The third cosmic velocity is the velocity needed for an object to escape the gravitational influence of the Sun (or any other central star) and travel into interstellar space. The escape velocity from the Sun can be derived similarly to the second cosmic velocity, but with the Sun's mass as the central body. The third cosmic velocity is given by: \\[ v_3 = \\sqrt{\\frac{2GM_{\\text{sun}}}{r}} \\] Where: \\(v_3\\) is the third cosmic velocity, \\(M_{\\text{sun}}\\) is the mass of the Sun (or the mass of another central star), \\(r\\) is the distance from the Sun (or the central star).","title":"3. Third Cosmic Velocity (Solar Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocities-for-different-celestial-bodies","text":"","title":"Cosmic Velocities for Different Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#table-1-velocities-for-earth-mars-and-jupiter","text":"The following table summarizes the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. Celestial Body Orbital Radius (m) First Cosmic Velocity (v\u2081) [m/s] Second Cosmic Velocity (v\u2082) [m/s] Third Cosmic Velocity (v\u2083) [m/s] Earth 6.371 \u00d7 10\u2076 7.12 \u00d7 10\u00b3 1.12 \u00d7 10\u2074 6.26 \u00d7 10\u2074 Mars 3.396 \u00d7 10\u2076 5.40 \u00d7 10\u00b3 9.51 \u00d7 10\u00b3 N/A Jupiter 6.991 \u00d7 10\u2077 1.29 \u00d7 10\u2074 1.83 \u00d7 10\u2074 N/A","title":"Table 1: Velocities for Earth, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code-for-calculating-and-visualizing-velocities","text":"Below is the Python code that calculates the first, second, and third cosmic velocities for various celestial bodies, including Earth, Mars, and Jupiter. It also visualizes these velocities using a bar chart. Learn more. import numpy as np import matplotlib.pyplot as plt def first_cosmic_velocity(G, M, r): \"\"\" Calculates the first cosmic velocity (orbital velocity). Parameters: G : float : Gravitational constant (m^3 kg^-1 s^-2) M : float : Mass of the celestial body (kg) r : float : Orbital radius (m) Returns: float : First cosmic velocity (m/s) \"\"\" return np.sqrt(G * M / r) def second_cosmic_velocity(G, M, r): \"\"\" Calculates the second cosmic velocity (escape velocity). Parameters: G : float : Gravitational constant (m^3 kg^-1 s^-2) M : float : Mass of the celestial body (kg) r : float : Orbital radius (m) Returns: float : Second cosmic velocity (m/s) \"\"\" return np.sqrt(2 * G * M / r) def third_cosmic_velocity(G, M_sun, r): \"\"\" Calculates the third cosmic velocity (velocity to escape the solar system). Parameters: G : float : Gravitational constant (m^3 kg^-1 s^-2) M_sun : float : Mass of the Sun (kg) r : float : Distance from the Sun (m) Returns: float : Third cosmic velocity (m/s) \"\"\" return np.sqrt(2 * G * M_sun / r) # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) M_mars = 6.4171e23 # Mass of Mars (kg) M_jupiter = 1.8982e27 # Mass of Jupiter (kg) M_sun = 1.989e30 # Mass of Sun (kg) # Radii (in meters) radii_earth = 6.371e6 # Radius of Earth (m) radii_mars = 3.396e6 # Radius of Mars (m) radii_jupiter = 6.991e7 # Radius of Jupiter (m) distance_sun_earth = 1.496e11 # Distance from Earth to Sun (m) # Compute cosmic velocities v1_earth = first_cosmic_velocity(G, M_earth, radii_earth) v2_earth = second_cosmic_velocity(G, M_earth, radii_earth) v3_earth = third_cosmic_velocity(G, M_sun, distance_sun_earth) v1_mars = first_cosmic_velocity(G, M_mars, radii_mars) v2_mars = second_cosmic_velocity(G, M_mars, radii_mars) v3_mars = third_cosmic_velocity(G, M_sun, distance_sun_earth) # Mars's escape from Sun v1_jupiter = first_cosmic_velocity(G, M_jupiter, radii_jupiter) v2_jupiter = second_cosmic_velocity(G, M_jupiter, radii_jupiter) v3_jupiter = third_cosmic_velocity(G, M_sun, distance_sun_earth) # Jupiter's escape from Sun # Output the velocities for each body print(f\"{'Celestial Body':<20}{'v1 (Orbital Velocity) [m/s]':<30}{'v2 (Escape Velocity) [m/s]':<30}{'v3 (Solar Escape Velocity) [m/s]':<30}\") print(\"-\" * 110) bodies = [\"Earth\", \"Mars\", \"Jupiter\"] velocities = [ (v1_earth, v2_earth, v3_earth), (v1_mars, v2_mars, v3_mars), (v1_jupiter, v2_jupiter, v3_jupiter) ] for i, body in enumerate(bodies): v3_val = velocities[i][2] if velocities[i][2] else \"N/A\" print(f\"{body:<20}{velocities[i][0]:<30.2f}{velocities[i][1]:<30.2f}{v3_val:<30}\") # Plot the velocities labels = [\"Orbital Velocity (v1)\", \"Escape Velocity (v2)\", \"Solar Escape Velocity (v3)\"] # Prepare data for plotting velocities_data = np.array([[ velocities[0][0], velocities[0][1], velocities[0][2]], [velocities[1][0], velocities[1][1], velocities[1][2]], [velocities[2][0], velocities[2][1], velocities[2][2]] ]) fig, ax = plt.subplots(figsize=(12, 7.5)) bar_width = 0.25 index = np.arange(len(bodies)) # Plot the bars bar1 = ax.bar(index - bar_width, velocities_data[:, 0], bar_width, label=labels[0]) bar2 = ax.bar(index, velocities_data[:, 1], bar_width, label=labels[1]) bar3 = ax.bar(index + bar_width, velocities_data[:, 2], bar_width, label=labels[2]) ax.set_xlabel('Celestial Bodies') ax.set_ylabel('Velocity (m/s)') ax.set_title('Cosmic Velocities for Different Celestial Bodies') ax.set_xticks(index) ax.set_xticklabels(bodies) ax.legend() plt.tight_layout() plt.show()","title":"Python Code for Calculating and Visualizing Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Introduction When a payload is released from a moving rocket near Earth, its trajectory depends on various factors such as its initial velocity, position, and the gravitational forces it experiences. Depending on these initial conditions, the payload can follow different types of trajectories such as elliptical, parabolic, or hyperbolic. These trajectories are critical for space missions, including satellite deployment, payload recovery, and even interplanetary travel. Understanding the different trajectories that a payload can follow, based on its velocity and position relative to Earth, is essential for mission planning. This document discusses the underlying physics of gravitational forces, derives the equations of motion, explains the types of possible trajectories, and provides a simulation of a payload's trajectory near Earth. Gravitational Force and Equations of Motion The motion of a payload near Earth is governed by Newton\u2019s law of gravitation. The gravitational force acting on an object of mass \\(m\\) at a distance \\(r\\) from the center of Earth is given by: \\[ F = \\frac{G M m}{r^2} \\] Where: \\(F\\) is the gravitational force (in newtons), \\(G\\) is the gravitational constant, \\(6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) , \\(M\\) is the mass of Earth ( \\(5.972 \\times 10^{24} \\, \\text{kg}\\) ), \\(m\\) is the mass of the payload, \\(r\\) is the distance from the center of Earth to the payload (in meters). The force is responsible for the acceleration of the payload towards Earth. The acceleration \\(a\\) is given by: \\[ a = \\frac{F}{m} = \\frac{GM}{r^2} \\] This is also referred to as gravitational acceleration . The second-order differential equation describing the motion of an object under Earth's gravity is: \\[ \\frac{d^2 r}{dt^2} = -\\frac{GM}{r^2} \\] This equation forms the foundation for calculating the trajectory of the payload. Types of Trajectories The trajectory of a payload released near Earth depends on its initial velocity. Based on the velocity, the trajectory could be one of the following: 1. Elliptical Trajectory When the initial velocity is less than the escape velocity, the payload follows an elliptical trajectory. The payload will eventually return to Earth after completing its elliptical orbit. This type of trajectory is typical for satellites in low Earth orbit (LEO). The equation for an elliptical orbit is derived from Kepler\u2019s Laws of Planetary Motion and is given by: \\[ r(t) = \\frac{a(1 - e^2)}{1 + e \\cos(\\theta)} \\] Where: \\(a\\) is the semi-major axis, \\(e\\) is the orbital eccentricity, \\(\\theta\\) is the true anomaly (the angle between the payload and the periapsis). 2. Parabolic Trajectory When the payload's initial velocity is equal to the escape velocity at a given distance from Earth, its trajectory will be parabolic. A parabolic trajectory is the boundary between bound and unbound motion, and it represents the exact condition for escaping Earth's gravity. The escape velocity at any point is given by: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] Where: \\(v_{\\text{esc}}\\) is the escape velocity, \\(r\\) is the distance from Earth's center. 3. Hyperbolic Trajectory If the payload's initial velocity exceeds the escape velocity, the trajectory will be hyperbolic. In this case, the payload escapes Earth's gravitational influence completely, traveling on a path that takes it far beyond Earth. The trajectory is open, meaning the payload will not return to Earth. For a hyperbolic trajectory, the total energy of the object is positive, and the velocity at infinity exceeds the escape velocity. Escape Velocity The escape velocity is the minimum velocity an object must have in order to escape the gravitational pull of Earth, without needing further propulsion. The escape velocity at a distance \\(r\\) from Earth's center is given by: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] Where: \\(v_{\\text{esc}}\\) is the escape velocity (m/s), \\(G\\) is the gravitational constant, \\(M\\) is the mass of Earth, \\(r\\) is the distance from Earth's center. At the Earth's surface ( \\(r = R_{\\text{Earth}}\\) ), the escape velocity is approximately 11.2 km/s. Numerical Simulation of Trajectories To simulate the trajectory of a payload under the influence of Earth\u2019s gravity, we use numerical methods, particularly the Runge-Kutta method to solve the equations of motion. Below is a Python script that simulates the trajectory of a payload based on its initial position and velocity. Learn more. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) R_earth = 6.371e6 # Radius of Earth (m) def gravitational_force(t, y): \"\"\" Computes the gravitational acceleration and velocity of the payload. Parameters: t : float : Time (s) y : array : State vector [x, y, vx, vy], where x, y are positions and vx, vy are velocities. Returns: dydt : array : Derivatives [vx, vy, ax, ay] \"\"\" x, y, vx, vy = y r = np.sqrt(x**2 + y**2) # Distance from the center of the Earth # Gravitational acceleration ax = -G * M_earth * x / r**3 ay = -G * M_earth * y / r**3 return [vx, vy, ax, ay] def simulate_trajectory(initial_conditions, t_span, t_eval): \"\"\" Simulates the trajectory of a payload released from Earth under the influence of gravity. Parameters: initial_conditions : array : Initial state [x0, y0, vx0, vy0] t_span : tuple : Time span (t0, tf) t_eval : array : Time steps at which to evaluate the solution Returns: sol : object : Solution object from scipy.integrate.solve_ivp \"\"\" sol = solve_ivp(gravitational_force, t_span, initial_conditions, t_eval=t_eval, method='RK45') return sol # Initial conditions for the payload (position in meters, velocity in m/s) initial_conditions = [R_earth + 100000, 0, 0, 5000] # Released 100 km above Earth, velocity in x-direction t_span = (0, 15000) # Simulate for 15000 seconds t_eval = np.linspace(t_span[0], t_span[1], 1000) # Simulate the trajectory sol = simulate_trajectory(initial_conditions, t_span, t_eval) # Extract the results x, y = sol.y[0], sol.y[1] # Plot the trajectory plt.figure(figsize=(12, 12)) plt.plot(x, y, label=\"Payload Trajectory\") plt.plot(0, 0, 'ro', label=\"Earth Center\") plt.axhline(0, color='black',linewidth=0.3) plt.axvline(0, color='black',linewidth=0.3) plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.title('Trajectory of Payload Released Near Earth') plt.legend() plt.grid(True) plt.show()","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#introduction","text":"When a payload is released from a moving rocket near Earth, its trajectory depends on various factors such as its initial velocity, position, and the gravitational forces it experiences. Depending on these initial conditions, the payload can follow different types of trajectories such as elliptical, parabolic, or hyperbolic. These trajectories are critical for space missions, including satellite deployment, payload recovery, and even interplanetary travel. Understanding the different trajectories that a payload can follow, based on its velocity and position relative to Earth, is essential for mission planning. This document discusses the underlying physics of gravitational forces, derives the equations of motion, explains the types of possible trajectories, and provides a simulation of a payload's trajectory near Earth.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_3/#gravitational-force-and-equations-of-motion","text":"The motion of a payload near Earth is governed by Newton\u2019s law of gravitation. The gravitational force acting on an object of mass \\(m\\) at a distance \\(r\\) from the center of Earth is given by: \\[ F = \\frac{G M m}{r^2} \\] Where: \\(F\\) is the gravitational force (in newtons), \\(G\\) is the gravitational constant, \\(6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) , \\(M\\) is the mass of Earth ( \\(5.972 \\times 10^{24} \\, \\text{kg}\\) ), \\(m\\) is the mass of the payload, \\(r\\) is the distance from the center of Earth to the payload (in meters). The force is responsible for the acceleration of the payload towards Earth. The acceleration \\(a\\) is given by: \\[ a = \\frac{F}{m} = \\frac{GM}{r^2} \\] This is also referred to as gravitational acceleration . The second-order differential equation describing the motion of an object under Earth's gravity is: \\[ \\frac{d^2 r}{dt^2} = -\\frac{GM}{r^2} \\] This equation forms the foundation for calculating the trajectory of the payload.","title":"Gravitational Force and Equations of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories","text":"The trajectory of a payload released near Earth depends on its initial velocity. Based on the velocity, the trajectory could be one of the following:","title":"Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-elliptical-trajectory","text":"When the initial velocity is less than the escape velocity, the payload follows an elliptical trajectory. The payload will eventually return to Earth after completing its elliptical orbit. This type of trajectory is typical for satellites in low Earth orbit (LEO). The equation for an elliptical orbit is derived from Kepler\u2019s Laws of Planetary Motion and is given by: \\[ r(t) = \\frac{a(1 - e^2)}{1 + e \\cos(\\theta)} \\] Where: \\(a\\) is the semi-major axis, \\(e\\) is the orbital eccentricity, \\(\\theta\\) is the true anomaly (the angle between the payload and the periapsis).","title":"1. Elliptical Trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-parabolic-trajectory","text":"When the payload's initial velocity is equal to the escape velocity at a given distance from Earth, its trajectory will be parabolic. A parabolic trajectory is the boundary between bound and unbound motion, and it represents the exact condition for escaping Earth's gravity. The escape velocity at any point is given by: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] Where: \\(v_{\\text{esc}}\\) is the escape velocity, \\(r\\) is the distance from Earth's center.","title":"2. Parabolic Trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-hyperbolic-trajectory","text":"If the payload's initial velocity exceeds the escape velocity, the trajectory will be hyperbolic. In this case, the payload escapes Earth's gravitational influence completely, traveling on a path that takes it far beyond Earth. The trajectory is open, meaning the payload will not return to Earth. For a hyperbolic trajectory, the total energy of the object is positive, and the velocity at infinity exceeds the escape velocity.","title":"3. Hyperbolic Trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape-velocity","text":"The escape velocity is the minimum velocity an object must have in order to escape the gravitational pull of Earth, without needing further propulsion. The escape velocity at a distance \\(r\\) from Earth's center is given by: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] Where: \\(v_{\\text{esc}}\\) is the escape velocity (m/s), \\(G\\) is the gravitational constant, \\(M\\) is the mass of Earth, \\(r\\) is the distance from Earth's center. At the Earth's surface ( \\(r = R_{\\text{Earth}}\\) ), the escape velocity is approximately 11.2 km/s.","title":"Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation-of-trajectories","text":"To simulate the trajectory of a payload under the influence of Earth\u2019s gravity, we use numerical methods, particularly the Runge-Kutta method to solve the equations of motion. Below is a Python script that simulates the trajectory of a payload based on its initial position and velocity. Learn more. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) R_earth = 6.371e6 # Radius of Earth (m) def gravitational_force(t, y): \"\"\" Computes the gravitational acceleration and velocity of the payload. Parameters: t : float : Time (s) y : array : State vector [x, y, vx, vy], where x, y are positions and vx, vy are velocities. Returns: dydt : array : Derivatives [vx, vy, ax, ay] \"\"\" x, y, vx, vy = y r = np.sqrt(x**2 + y**2) # Distance from the center of the Earth # Gravitational acceleration ax = -G * M_earth * x / r**3 ay = -G * M_earth * y / r**3 return [vx, vy, ax, ay] def simulate_trajectory(initial_conditions, t_span, t_eval): \"\"\" Simulates the trajectory of a payload released from Earth under the influence of gravity. Parameters: initial_conditions : array : Initial state [x0, y0, vx0, vy0] t_span : tuple : Time span (t0, tf) t_eval : array : Time steps at which to evaluate the solution Returns: sol : object : Solution object from scipy.integrate.solve_ivp \"\"\" sol = solve_ivp(gravitational_force, t_span, initial_conditions, t_eval=t_eval, method='RK45') return sol # Initial conditions for the payload (position in meters, velocity in m/s) initial_conditions = [R_earth + 100000, 0, 0, 5000] # Released 100 km above Earth, velocity in x-direction t_span = (0, 15000) # Simulate for 15000 seconds t_eval = np.linspace(t_span[0], t_span[1], 1000) # Simulate the trajectory sol = simulate_trajectory(initial_conditions, t_span, t_eval) # Extract the results x, y = sol.y[0], sol.y[1] # Plot the trajectory plt.figure(figsize=(12, 12)) plt.plot(x, y, label=\"Payload Trajectory\") plt.plot(0, 0, 'ro', label=\"Earth Center\") plt.axhline(0, color='black',linewidth=0.3) plt.axvline(0, color='black',linewidth=0.3) plt.xlabel('X Position (m)') plt.ylabel('Y Position (m)') plt.title('Trajectory of Payload Released Near Earth') plt.legend() plt.grid(True) plt.show()","title":"Numerical Simulation of Trajectories"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"}]}