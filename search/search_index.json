{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Projectile Motion Analysis and Simulation Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation Projectile motion is a fundamental topic in classical mechanics, describing the motion of an object launched into the air under the influence of gravity. It plays a crucial role in various real-world applications, such as ballistics, sports, and space exploration. Understanding projectile motion requires analyzing both horizontal and vertical components independently, assuming no external forces except gravity (neglecting air resistance initially). By exploring its equations, derivations, and computational approaches, we can gain deeper insights into the factors influencing projectile trajectory. 1.1 Equations of Motion The motion of a projectile launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) is governed by the fundamental kinematic equations. 1.1.1 Horizontal Motion Since there is no horizontal acceleration (neglecting air resistance), the horizontal displacement is given by: \\[ x = v_0 \\cos(\\theta) t \\] where: \\( x \\) = horizontal displacement \\( v_0 \\) = initial velocity \\( \\theta \\) = launch angle \\( t \\) = time 1.1.2 Vertical Motion The vertical motion is influenced by gravity \\( g \\) , leading to the equation: \\[ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] where: \\( y \\) = vertical displacement \\( g \\) = acceleration due to gravity (9.81 m/s\u00b2) 1.2 Derivation of Key Equations 1.2.1 Time of Flight The total time of flight occurs when the projectile returns to the ground (i.e., \\( y = 0 \\) ). Setting the vertical displacement equation to zero: \\[ 0 = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] Factoring out \\( t \\) : \\[ t (v_0 \\sin(\\theta) - \\frac{1}{2} g t) = 0 \\] Solving for \\( t \\) : \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] 1.2.2 Range of the Projectile The range \\( R \\) is the horizontal distance traveled before the projectile lands: \\[ R = v_0 \\cos(\\theta) t_f \\] Substituting \\( t_f \\) from above: \\[ R = v_0 \\cos(\\theta) \\times \\frac{2 v_0 \\sin(\\theta)}{g} \\] Using the trigonometric identity \\( 2 \\sin(\\theta) \\cos(\\theta) = \\sin(2\\theta) \\) , we get: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] 1.2.3 Maximum Height At the peak, the vertical velocity is zero \\( (v_y = 0) \\) . Using the kinematic equation: \\[ v_y^2 = v_0^2 \\sin^2(\\theta) - 2 g H \\] Setting \\( v_y = 0 \\) : \\[ 0 = v_0^2 \\sin^2(\\theta) - 2 g H \\] Solving for \\( H \\) : \\[ H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\] 1.3 Effects of Air Resistance Without air resistance, projectiles follow a parabolic trajectory . However, with air resistance, the motion becomes more complex due to a drag force \\( F_d \\) , given by: \\[ F_d = \\frac{1}{2} C_d \\rho A v^2 \\] where: \\( C_d \\) = drag coefficient (depends on object shape) \\( \\rho \\) = air density (kg/m\u00b3) \\( A \\) = cross-sectional area (m\u00b2) \\( v \\) = velocity (m/s) 1.4 Numerical Computation with Air Resistance With air resistance, the equations of motion become nonlinear differential equations: 1.4.1 Horizontal Motion with Drag \\[ m \\frac{dv_x}{dt} = -\\frac{1}{2} C_d \\rho A v v_x \\] 1.4.2 Vertical Motion with Drag \\[ m \\frac{dv_y}{dt} = -mg - \\frac{1}{2} C_d \\rho A v v_y \\] where \\( v_x \\) and \\( v_y \\) are the horizontal and vertical velocity components. These equations require numerical methods (such as Euler\u2019s method or Runge-Kutta) for solving. 1.5 Summary of Important Equations Quantity Equation Horizontal Position \\( x = v_0 \\cos(\\theta) t \\) Vertical Position \\( y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\) Time of Flight \\( t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\) Range \\( R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\) Maximum Height \\( H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\) Drag Force \\( F_d = \\frac{1}{2} C_d \\rho A v^2 \\) 2. Analytical Analysis of Range This section plots range vs. launch angle without air resistance. Learn more. import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # gravitational acceleration (m/s\u00b2) v0 = 10 # initial velocity (m/s) # Angle range (0\u00b0 to 90\u00b0) theta = np.linspace(0, 90, 100) theta_rad = np.radians(theta) # Convert to radians # Compute range R = (v0**2 * np.sin(2 * theta_rad)) / g # Plot range vs. angle plt.figure(figsize=(12, 7.5)) plt.plot(theta, R, label=f'Initial velocity = {v0} m/s') plt.xlabel('Launch Angle (\u00b0)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show() 3. Numerical Simulation with Air Resistance Here, we use ODE solvers to simulate projectile motion with drag. Learn more. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # Gravity (m/s\u00b2) rho = 1.225 # Air density (kg/m\u00b3) Cd = 0.47 # Drag coefficient (sphere) A = 0.01 # Cross-sectional area (m\u00b2) m = 0.145 # Mass of projectile (kg) (e.g., baseball) def equations(t, state, Cd, A, m, rho): \"\"\"Differential equations for projectile motion with air resistance.\"\"\" x, y, vx, vy = state v = np.sqrt(vx**2 + vy**2) # Speed drag = (0.5 * Cd * rho * A * v**2) / m # Drag acceleration ax = -drag * (vx / v) # Drag in x-direction ay = -g - drag * (vy / v) # Drag in y-direction return [vx, vy, ax, ay] def solve_projectile(v0, theta_deg, Cd=0.47): \"\"\"Solve projectile motion with air resistance using numerical integration.\"\"\" theta = np.radians(theta_deg) vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) # Initial conditions state0 = [0, 0, vx0, vy0] # Solve using solve_ivp t_span = (0, 5) # Time range t_eval = np.linspace(0, 5, 300) # Time points for solution sol = solve_ivp(equations, t_span, state0, t_eval=t_eval, args=(Cd, A, m, rho)) return sol.t, sol.y[0], sol.y[1] # Time, x, y def plot_trajectory(arr_args): \"\"\"Plots projectile motion with adjustable parameters.\"\"\" plt.figure(figsize=(12, 7.5)) for item in arr_args: v0, theta_deg, Cd = item t, x, y = solve_projectile(v0, theta_deg, Cd) plt.plot(x, y, label=f'v0={v0} m/s, \u03b8={theta_deg}\u00b0, Cd={Cd}') plt.xlabel('Distance (m)') plt.ylabel('Height (m)') plt.title('Projectile Motion with Air Resistance') plt.legend() plt.grid() plt.ylim(0) # Ensure ground level is visible plt.show() # Example Plot plot_trajectory([(40, 45, 0.47), (40, 45, 0.2), (40, 45, 0.1), (40, 40, 0.47), (40, 30, 0.47), (40, 20, 0.47), (30, 40, 0.47), (20, 40, 0.47), (15, 40, 0.47)]) 4. Interactive Simulation This section adds sliders for interactive tuning of launch parameters. Learn more. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp import ipywidgets as widgets from IPython.display import display # Constants g = 9.81 # Gravity (m/s\u00b2) rho = 1.225 # Air density (kg/m\u00b3) A = 0.01 # Cross-sectional area (m\u00b2) m = 0.145 # Mass of projectile (kg) (e.g., baseball) # Define equations of motion def equations(t, state, Cd, A, m, rho): x, y, vx, vy = state v = np.sqrt(vx**2 + vy**2) # Speed magnitude drag = (0.5 * Cd * rho * A * v**2) / m # Drag force ax = -drag * (vx / v) # Acceleration in x ay = -g - drag * (vy / v) # Acceleration in y return [vx, vy, ax, ay] # Solve equations using Runge-Kutta def solve_projectile(v0, theta_deg, Cd): theta = np.radians(theta_deg) vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) state0 = [0, 0, vx0, vy0] t_span = (0, 5) t_eval = np.linspace(0, 5, 300) sol = solve_ivp(equations, t_span, state0, t_eval=t_eval, args=(Cd, A, m, rho)) return sol.y[0], sol.y[1] # Return x and y coordinates # Function to update plot dynamically def update_plot(v0, theta_deg, Cd): fig, ax = plt.subplots(figsize=(12, 7.5)) # Create new figure each time ax.set_xlabel('Distance (m)') ax.set_ylabel('Height (m)') ax.set_title('Projectile Motion with Air Resistance') ax.set_xlim(0, 50) # Set fixed axis limits ax.set_ylim(0, 15) ax.grid() x, y = solve_projectile(v0, theta_deg, Cd) # Solve motion equations ax.plot(x, y, label=f'v0={v0} m/s, \u03b8={theta_deg}\u00b0, Cd={Cd}', color='b') ax.legend() plt.show() # Display updated plot # Interactive widgets v0_slider = widgets.FloatSlider(value=20, min=5, max=50, step=1, description='v0 (m/s)') theta_slider = widgets.FloatSlider(value=45, min=0, max=90, step=1, description='Angle (\u00b0)') Cd_slider = widgets.FloatSlider(value=0.47, min=0, max=1.5, step=0.05, description='Cd (Drag)') # Link widgets with update function out = widgets.interactive_output(update_plot, {'v0': v0_slider, 'theta_deg': theta_slider, 'Cd': Cd_slider}) # Display the widgets and plot ui = widgets.VBox([v0_slider, theta_slider, Cd_slider]) display(ui, out) 5. Launch from Different Heights We modify our simulation to allow for launch at y\u2080\u22600. This affects the time of flight calculation. Learn more. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # Gravity (m/s\u00b2) rho = 1.225 # Air density (kg/m\u00b3) Cd = 0.47 # Drag coefficient (sphere) A = 0.01 # Cross-sectional area (m\u00b2) m = 0.145 # Mass of projectile (kg) (e.g., baseball) def equations(t, state, Cd, A, m, rho): \"\"\"Differential equations for projectile motion with air resistance.\"\"\" x, y, vx, vy = state v = np.sqrt(vx**2 + vy**2) # Speed drag = (0.5 * Cd * rho * A * v**2) / m # Drag acceleration ax = -drag * (vx / v) # Drag in x-direction ay = -g - drag * (vy / v) # Drag in y-direction return [vx, vy, ax, ay] def solve_projectile_height(v0, theta_deg, y0, Cd=0.47): \"\"\"Solve projectile motion with different initial heights.\"\"\" theta = np.radians(theta_deg) vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) # Initial conditions state0 = [0, y0, vx0, vy0] # Solve sol = solve_ivp(equations, (0, 10), state0, t_eval=np.linspace(0, 10, 500), args=(Cd, A, m, rho)) return sol.t, sol.y[0], sol.y[1] # Example Plot def plot_trajectory(para_list): plt.figure(figsize=(12, 7.5)) for para in para_list: v0, theta_deg, Cd, init_height = para t, x, y = solve_projectile_height(v0, theta_deg, init_height, Cd) plt.plot(x, y, label=f'v0={v0} m/s, \u03b8={theta_deg}\u00b0, Cd={Cd}, y0={init_height}m') plt.xlabel('Distance (m)') plt.ylabel('Height (m)') plt.title('Projectile Motion with Air Resistance') plt.legend() plt.grid() plt.ylim(0) plt.show() # Example: Launch from different height plot_trajectory([(20, 45, 0.47, 3), (20, 45, 0.47, 6), (20, 45, 0.47, 9), (20, 45, 0.47, 12)])","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-analysis-and-simulation","text":"","title":"Projectile Motion Analysis and Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion is a fundamental topic in classical mechanics, describing the motion of an object launched into the air under the influence of gravity. It plays a crucial role in various real-world applications, such as ballistics, sports, and space exploration. Understanding projectile motion requires analyzing both horizontal and vertical components independently, assuming no external forces except gravity (neglecting air resistance initially). By exploring its equations, derivations, and computational approaches, we can gain deeper insights into the factors influencing projectile trajectory.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-equations-of-motion","text":"The motion of a projectile launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) is governed by the fundamental kinematic equations.","title":"1.1 Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#111-horizontal-motion","text":"Since there is no horizontal acceleration (neglecting air resistance), the horizontal displacement is given by: \\[ x = v_0 \\cos(\\theta) t \\] where: \\( x \\) = horizontal displacement \\( v_0 \\) = initial velocity \\( \\theta \\) = launch angle \\( t \\) = time","title":"1.1.1 Horizontal Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#112-vertical-motion","text":"The vertical motion is influenced by gravity \\( g \\) , leading to the equation: \\[ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] where: \\( y \\) = vertical displacement \\( g \\) = acceleration due to gravity (9.81 m/s\u00b2)","title":"1.1.2 Vertical Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-derivation-of-key-equations","text":"","title":"1.2 Derivation of Key Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#121-time-of-flight","text":"The total time of flight occurs when the projectile returns to the ground (i.e., \\( y = 0 \\) ). Setting the vertical displacement equation to zero: \\[ 0 = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] Factoring out \\( t \\) : \\[ t (v_0 \\sin(\\theta) - \\frac{1}{2} g t) = 0 \\] Solving for \\( t \\) : \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\]","title":"1.2.1 Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#122-range-of-the-projectile","text":"The range \\( R \\) is the horizontal distance traveled before the projectile lands: \\[ R = v_0 \\cos(\\theta) t_f \\] Substituting \\( t_f \\) from above: \\[ R = v_0 \\cos(\\theta) \\times \\frac{2 v_0 \\sin(\\theta)}{g} \\] Using the trigonometric identity \\( 2 \\sin(\\theta) \\cos(\\theta) = \\sin(2\\theta) \\) , we get: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"1.2.2 Range of the Projectile"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#123-maximum-height","text":"At the peak, the vertical velocity is zero \\( (v_y = 0) \\) . Using the kinematic equation: \\[ v_y^2 = v_0^2 \\sin^2(\\theta) - 2 g H \\] Setting \\( v_y = 0 \\) : \\[ 0 = v_0^2 \\sin^2(\\theta) - 2 g H \\] Solving for \\( H \\) : \\[ H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\]","title":"1.2.3 Maximum Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-effects-of-air-resistance","text":"Without air resistance, projectiles follow a parabolic trajectory . However, with air resistance, the motion becomes more complex due to a drag force \\( F_d \\) , given by: \\[ F_d = \\frac{1}{2} C_d \\rho A v^2 \\] where: \\( C_d \\) = drag coefficient (depends on object shape) \\( \\rho \\) = air density (kg/m\u00b3) \\( A \\) = cross-sectional area (m\u00b2) \\( v \\) = velocity (m/s)","title":"1.3 Effects of Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#14-numerical-computation-with-air-resistance","text":"With air resistance, the equations of motion become nonlinear differential equations:","title":"1.4 Numerical Computation with Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#141-horizontal-motion-with-drag","text":"\\[ m \\frac{dv_x}{dt} = -\\frac{1}{2} C_d \\rho A v v_x \\]","title":"1.4.1 Horizontal Motion with Drag"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#142-vertical-motion-with-drag","text":"\\[ m \\frac{dv_y}{dt} = -mg - \\frac{1}{2} C_d \\rho A v v_y \\] where \\( v_x \\) and \\( v_y \\) are the horizontal and vertical velocity components. These equations require numerical methods (such as Euler\u2019s method or Runge-Kutta) for solving.","title":"1.4.2 Vertical Motion with Drag"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#15-summary-of-important-equations","text":"Quantity Equation Horizontal Position \\( x = v_0 \\cos(\\theta) t \\) Vertical Position \\( y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\) Time of Flight \\( t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\) Range \\( R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\) Maximum Height \\( H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\) Drag Force \\( F_d = \\frac{1}{2} C_d \\rho A v^2 \\)","title":"1.5 Summary of Important Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analytical-analysis-of-range","text":"This section plots range vs. launch angle without air resistance. Learn more. import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # gravitational acceleration (m/s\u00b2) v0 = 10 # initial velocity (m/s) # Angle range (0\u00b0 to 90\u00b0) theta = np.linspace(0, 90, 100) theta_rad = np.radians(theta) # Convert to radians # Compute range R = (v0**2 * np.sin(2 * theta_rad)) / g # Plot range vs. angle plt.figure(figsize=(12, 7.5)) plt.plot(theta, R, label=f'Initial velocity = {v0} m/s') plt.xlabel('Launch Angle (\u00b0)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show()","title":"2. Analytical Analysis of Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-numerical-simulation-with-air-resistance","text":"Here, we use ODE solvers to simulate projectile motion with drag. Learn more. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # Gravity (m/s\u00b2) rho = 1.225 # Air density (kg/m\u00b3) Cd = 0.47 # Drag coefficient (sphere) A = 0.01 # Cross-sectional area (m\u00b2) m = 0.145 # Mass of projectile (kg) (e.g., baseball) def equations(t, state, Cd, A, m, rho): \"\"\"Differential equations for projectile motion with air resistance.\"\"\" x, y, vx, vy = state v = np.sqrt(vx**2 + vy**2) # Speed drag = (0.5 * Cd * rho * A * v**2) / m # Drag acceleration ax = -drag * (vx / v) # Drag in x-direction ay = -g - drag * (vy / v) # Drag in y-direction return [vx, vy, ax, ay] def solve_projectile(v0, theta_deg, Cd=0.47): \"\"\"Solve projectile motion with air resistance using numerical integration.\"\"\" theta = np.radians(theta_deg) vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) # Initial conditions state0 = [0, 0, vx0, vy0] # Solve using solve_ivp t_span = (0, 5) # Time range t_eval = np.linspace(0, 5, 300) # Time points for solution sol = solve_ivp(equations, t_span, state0, t_eval=t_eval, args=(Cd, A, m, rho)) return sol.t, sol.y[0], sol.y[1] # Time, x, y def plot_trajectory(arr_args): \"\"\"Plots projectile motion with adjustable parameters.\"\"\" plt.figure(figsize=(12, 7.5)) for item in arr_args: v0, theta_deg, Cd = item t, x, y = solve_projectile(v0, theta_deg, Cd) plt.plot(x, y, label=f'v0={v0} m/s, \u03b8={theta_deg}\u00b0, Cd={Cd}') plt.xlabel('Distance (m)') plt.ylabel('Height (m)') plt.title('Projectile Motion with Air Resistance') plt.legend() plt.grid() plt.ylim(0) # Ensure ground level is visible plt.show() # Example Plot plot_trajectory([(40, 45, 0.47), (40, 45, 0.2), (40, 45, 0.1), (40, 40, 0.47), (40, 30, 0.47), (40, 20, 0.47), (30, 40, 0.47), (20, 40, 0.47), (15, 40, 0.47)])","title":"3. Numerical Simulation with Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-interactive-simulation","text":"This section adds sliders for interactive tuning of launch parameters. Learn more. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp import ipywidgets as widgets from IPython.display import display # Constants g = 9.81 # Gravity (m/s\u00b2) rho = 1.225 # Air density (kg/m\u00b3) A = 0.01 # Cross-sectional area (m\u00b2) m = 0.145 # Mass of projectile (kg) (e.g., baseball) # Define equations of motion def equations(t, state, Cd, A, m, rho): x, y, vx, vy = state v = np.sqrt(vx**2 + vy**2) # Speed magnitude drag = (0.5 * Cd * rho * A * v**2) / m # Drag force ax = -drag * (vx / v) # Acceleration in x ay = -g - drag * (vy / v) # Acceleration in y return [vx, vy, ax, ay] # Solve equations using Runge-Kutta def solve_projectile(v0, theta_deg, Cd): theta = np.radians(theta_deg) vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) state0 = [0, 0, vx0, vy0] t_span = (0, 5) t_eval = np.linspace(0, 5, 300) sol = solve_ivp(equations, t_span, state0, t_eval=t_eval, args=(Cd, A, m, rho)) return sol.y[0], sol.y[1] # Return x and y coordinates # Function to update plot dynamically def update_plot(v0, theta_deg, Cd): fig, ax = plt.subplots(figsize=(12, 7.5)) # Create new figure each time ax.set_xlabel('Distance (m)') ax.set_ylabel('Height (m)') ax.set_title('Projectile Motion with Air Resistance') ax.set_xlim(0, 50) # Set fixed axis limits ax.set_ylim(0, 15) ax.grid() x, y = solve_projectile(v0, theta_deg, Cd) # Solve motion equations ax.plot(x, y, label=f'v0={v0} m/s, \u03b8={theta_deg}\u00b0, Cd={Cd}', color='b') ax.legend() plt.show() # Display updated plot # Interactive widgets v0_slider = widgets.FloatSlider(value=20, min=5, max=50, step=1, description='v0 (m/s)') theta_slider = widgets.FloatSlider(value=45, min=0, max=90, step=1, description='Angle (\u00b0)') Cd_slider = widgets.FloatSlider(value=0.47, min=0, max=1.5, step=0.05, description='Cd (Drag)') # Link widgets with update function out = widgets.interactive_output(update_plot, {'v0': v0_slider, 'theta_deg': theta_slider, 'Cd': Cd_slider}) # Display the widgets and plot ui = widgets.VBox([v0_slider, theta_slider, Cd_slider]) display(ui, out)","title":"4. Interactive Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-launch-from-different-heights","text":"We modify our simulation to allow for launch at y\u2080\u22600. This affects the time of flight calculation. Learn more. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # Gravity (m/s\u00b2) rho = 1.225 # Air density (kg/m\u00b3) Cd = 0.47 # Drag coefficient (sphere) A = 0.01 # Cross-sectional area (m\u00b2) m = 0.145 # Mass of projectile (kg) (e.g., baseball) def equations(t, state, Cd, A, m, rho): \"\"\"Differential equations for projectile motion with air resistance.\"\"\" x, y, vx, vy = state v = np.sqrt(vx**2 + vy**2) # Speed drag = (0.5 * Cd * rho * A * v**2) / m # Drag acceleration ax = -drag * (vx / v) # Drag in x-direction ay = -g - drag * (vy / v) # Drag in y-direction return [vx, vy, ax, ay] def solve_projectile_height(v0, theta_deg, y0, Cd=0.47): \"\"\"Solve projectile motion with different initial heights.\"\"\" theta = np.radians(theta_deg) vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) # Initial conditions state0 = [0, y0, vx0, vy0] # Solve sol = solve_ivp(equations, (0, 10), state0, t_eval=np.linspace(0, 10, 500), args=(Cd, A, m, rho)) return sol.t, sol.y[0], sol.y[1] # Example Plot def plot_trajectory(para_list): plt.figure(figsize=(12, 7.5)) for para in para_list: v0, theta_deg, Cd, init_height = para t, x, y = solve_projectile_height(v0, theta_deg, init_height, Cd) plt.plot(x, y, label=f'v0={v0} m/s, \u03b8={theta_deg}\u00b0, Cd={Cd}, y0={init_height}m') plt.xlabel('Distance (m)') plt.ylabel('Height (m)') plt.title('Projectile Motion with Air Resistance') plt.legend() plt.grid() plt.ylim(0) plt.show() # Example: Launch from different height plot_trajectory([(20, 45, 0.47, 3), (20, 45, 0.47, 6), (20, 45, 0.47, 9), (20, 45, 0.47, 12)])","title":"5. Launch from Different Heights"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a fascinating example of a system where damping, restoring forces, and external periodic forcing interplay to create rich dynamic behavior. This system exhibits a variety of phenomena, including resonance, chaos, and quasiperiodicity, making it a valuable subject for studying complex real-world systems such as driven oscillators, climate models, and mechanical structures under periodic stress. By adjusting parameters like damping, external force amplitude, and driving frequency, the system transitions through different behaviors, such as synchronized oscillations, chaotic motion, and resonance phenomena. Understanding these behaviors has significant implications for fields like energy harvesting, vibration isolation, and mechanical resonance. Theoretical Foundation The motion of a forced damped pendulum is governed by the differential equation: \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t)\\] where: \\( \\theta(t) \\) is the angular displacement, \\( b \\) is the damping coefficient, \\( g \\) is the gravitational acceleration, \\( L \\) is the length of the pendulum, \\( A \\) is the amplitude of the external force, \\( \\omega \\) is the driving frequency. Small-Angle Approximation For small angles, we approximate \\( \\sin\\theta \\approx \\theta \\) , reducing the equation to: \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t)\\] This equation describes a forced damped harmonic oscillator with the general solution: \\[\\theta(t) = \\theta_0 e^{-bt/2} \\cos(\\omega t - \\delta)\\] where \\( \\theta_0 \\) and \\( \\delta \\) depend on the system parameters. Resonance Conditions Resonance occurs when the driving frequency \\( \\omega \\) matches the natural frequency: \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] At resonance, the amplitude grows significantly unless limited by damping. Analysis of Dynamics Effects of Parameters Damping coefficient ( \\( b \\) ) : Higher damping reduces oscillation amplitude and affects stability. Driving amplitude ( \\( A \\) ) : Higher values increase oscillation response and can induce chaotic behavior. Driving frequency ( \\( \\omega \\) ) : Near resonance, large oscillations appear, leading to energy amplification. Transition to Chaos Beyond simple oscillations, varying \\( b \\) , \\( A \\) , and \\( \\omega \\) leads to quasiperiodic or chaotic motion. The transition to chaos can be observed using bifurcation diagrams and Poincar\u00e9 sections. These chaotic behaviors arise from the system\u2019s sensitivity to initial conditions, a hallmark of deterministic chaos. Practical Applications Energy Harvesting : Used in piezoelectric devices to convert oscillatory motion into electrical energy. Suspension Bridges : Models forced oscillations under periodic forces, such as wind or traffic-induced vibrations. Oscillating Circuits : Analogous to driven RLC circuits, where voltage replaces angular displacement and current replaces velocity. Biological Rhythms : Similar dynamics appear in human gait patterns and circadian rhythms under external influences. Seismic Engineering : Structures subjected to periodic seismic forcing can be analyzed using pendulum models. Planetary Motion : Certain planetary rotational dynamics exhibit nonlinear oscillatory behavior similar to forced pendulums. Graphical Representations Time Series : Plots of \\( \\theta(t) \\) to observe periodicity or chaos. Learn more. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def forced_damped_pendulum(t, y, b, g, L, A, omega_d): \"\"\"ODE system for a forced damped pendulum.\"\"\" theta, omega = y # omega represents angular velocity (dtheta/dt) dtheta_dt = omega domega_dt = -b * omega - (g/L) * np.sin(theta) + A * np.cos(omega_d * t) # Corrected force term return [dtheta_dt, domega_dt] # Parameters g = 9.81 # Gravity (m/s^2) L = 1.0 # Length of pendulum (m) y0 = [np.pi / 4, 0] # Initial angle = 45 degrees, initial velocity = 0 # Five distinct parameter sets to compare cases = [ {\"b\": 0.2, \"A\": 1.0, \"omega_d\": 1.5, \"label\": \"b=0.2, A=1.0, \u03c9=1.5\"}, {\"b\": 0.5, \"A\": 1.2, \"omega_d\": 2.0, \"label\": \"b=0.5, A=1.2, \u03c9=2.0\"}, {\"b\": 0.8, \"A\": 1.5, \"omega_d\": 2.5, \"label\": \"b=0.8, A=1.5, \u03c9=2.5\"}, {\"b\": 0.3, \"A\": 2.0, \"omega_d\": 0.5, \"label\": \"b=0.3, A=2.0, \u03c9=0.5\"}, # Moderate damping, low frequency {\"b\": 0.7, \"A\": 1.8, \"omega_d\": 1.8, \"label\": \"b=0.7, A=1.8, \u03c9=1.8\"}, # Strong damping, medium frequency ] # Time range t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 1000) plt.figure(figsize=(12, 7.5)) # Solve and plot for the 5 cases for case in cases: sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(case[\"b\"], g, L, case[\"A\"], case[\"omega_d\"])) plt.plot(sol.t, sol.y[0], label=case[\"label\"]) # Formatting the plot plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.title('Forced Damped Pendulum Motion (5 Cases)') plt.legend() plt.grid(True) plt.show() Phase Portraits : \\( \\theta \\) vs. \\( \\frac{d\\theta}{dt} \\) to analyze system stability and attractors. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def forced_damped_pendulum(t, y, b, g, L, A, omega): \"\"\"ODE system for a forced damped pendulum.\"\"\" theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g/L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters g = 9.81 # Gravity (m/s\u00b2) L = 1.0 # Length of pendulum (m) y0 = [np.pi / 4, 0] # Initial angle = 45 degrees, initial velocity = 0 # Different parameter sets to compare cases = [ {\"b\": 0.2, \"A\": 1.0, \"omega\": 1.5, \"color\": \"r\", \"label\": \"b=0.2, A=1.0, \u03c9=1.5\"}, {\"b\": 0.5, \"A\": 1.2, \"omega\": 2.0, \"color\": \"b\", \"label\": \"b=0.5, A=1.2, \u03c9=2.0\"}, {\"b\": 0.8, \"A\": 1.5, \"omega\": 2.5, \"color\": \"g\", \"label\": \"b=0.8, A=1.5, \u03c9=2.5\"}, ] # Time range t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 1000) plt.figure(figsize=(12, 7.5)) # Solve and plot for different cases for case in cases: sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(case[\"b\"], g, L, case[\"A\"], case[\"omega\"])) plt.plot(sol.y[0], sol.y[1], color=case[\"color\"], label=case[\"label\"]) # Formatting plt.xlabel('Theta (angle)') plt.ylabel('Angular Velocity') plt.title('Phase Portrait of Forced Damped Pendulum') plt.legend() plt.grid(True) plt.show() Conclusion This study of the forced damped pendulum provides insight into nonlinear dynamics, resonance, and chaos, with applications in physics and engineering. By using numerical simulations, we can explore a range of behaviors from simple periodic motion to chaotic dynamics, offering deeper understanding and practical implications in various scientific domains. The forced damped pendulum serves as a fundamental model for diverse physical systems, reinforcing the significance of nonlinear dynamics in both theoretical and applied research.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a fascinating example of a system where damping, restoring forces, and external periodic forcing interplay to create rich dynamic behavior. This system exhibits a variety of phenomena, including resonance, chaos, and quasiperiodicity, making it a valuable subject for studying complex real-world systems such as driven oscillators, climate models, and mechanical structures under periodic stress. By adjusting parameters like damping, external force amplitude, and driving frequency, the system transitions through different behaviors, such as synchronized oscillations, chaotic motion, and resonance phenomena. Understanding these behaviors has significant implications for fields like energy harvesting, vibration isolation, and mechanical resonance.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#theoretical-foundation","text":"The motion of a forced damped pendulum is governed by the differential equation: \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t)\\] where: \\( \\theta(t) \\) is the angular displacement, \\( b \\) is the damping coefficient, \\( g \\) is the gravitational acceleration, \\( L \\) is the length of the pendulum, \\( A \\) is the amplitude of the external force, \\( \\omega \\) is the driving frequency.","title":"Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small angles, we approximate \\( \\sin\\theta \\approx \\theta \\) , reducing the equation to: \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t)\\] This equation describes a forced damped harmonic oscillator with the general solution: \\[\\theta(t) = \\theta_0 e^{-bt/2} \\cos(\\omega t - \\delta)\\] where \\( \\theta_0 \\) and \\( \\delta \\) depend on the system parameters.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","text":"Resonance occurs when the driving frequency \\( \\omega \\) matches the natural frequency: \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] At resonance, the amplitude grows significantly unless limited by damping.","title":"Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#analysis-of-dynamics","text":"","title":"Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effects-of-parameters","text":"Damping coefficient ( \\( b \\) ) : Higher damping reduces oscillation amplitude and affects stability. Driving amplitude ( \\( A \\) ) : Higher values increase oscillation response and can induce chaotic behavior. Driving frequency ( \\( \\omega \\) ) : Near resonance, large oscillations appear, leading to energy amplification.","title":"Effects of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-to-chaos","text":"Beyond simple oscillations, varying \\( b \\) , \\( A \\) , and \\( \\omega \\) leads to quasiperiodic or chaotic motion. The transition to chaos can be observed using bifurcation diagrams and Poincar\u00e9 sections. These chaotic behaviors arise from the system\u2019s sensitivity to initial conditions, a hallmark of deterministic chaos.","title":"Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#practical-applications","text":"Energy Harvesting : Used in piezoelectric devices to convert oscillatory motion into electrical energy. Suspension Bridges : Models forced oscillations under periodic forces, such as wind or traffic-induced vibrations. Oscillating Circuits : Analogous to driven RLC circuits, where voltage replaces angular displacement and current replaces velocity. Biological Rhythms : Similar dynamics appear in human gait patterns and circadian rhythms under external influences. Seismic Engineering : Structures subjected to periodic seismic forcing can be analyzed using pendulum models. Planetary Motion : Certain planetary rotational dynamics exhibit nonlinear oscillatory behavior similar to forced pendulums.","title":"Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#graphical-representations","text":"Time Series : Plots of \\( \\theta(t) \\) to observe periodicity or chaos. Learn more. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def forced_damped_pendulum(t, y, b, g, L, A, omega_d): \"\"\"ODE system for a forced damped pendulum.\"\"\" theta, omega = y # omega represents angular velocity (dtheta/dt) dtheta_dt = omega domega_dt = -b * omega - (g/L) * np.sin(theta) + A * np.cos(omega_d * t) # Corrected force term return [dtheta_dt, domega_dt] # Parameters g = 9.81 # Gravity (m/s^2) L = 1.0 # Length of pendulum (m) y0 = [np.pi / 4, 0] # Initial angle = 45 degrees, initial velocity = 0 # Five distinct parameter sets to compare cases = [ {\"b\": 0.2, \"A\": 1.0, \"omega_d\": 1.5, \"label\": \"b=0.2, A=1.0, \u03c9=1.5\"}, {\"b\": 0.5, \"A\": 1.2, \"omega_d\": 2.0, \"label\": \"b=0.5, A=1.2, \u03c9=2.0\"}, {\"b\": 0.8, \"A\": 1.5, \"omega_d\": 2.5, \"label\": \"b=0.8, A=1.5, \u03c9=2.5\"}, {\"b\": 0.3, \"A\": 2.0, \"omega_d\": 0.5, \"label\": \"b=0.3, A=2.0, \u03c9=0.5\"}, # Moderate damping, low frequency {\"b\": 0.7, \"A\": 1.8, \"omega_d\": 1.8, \"label\": \"b=0.7, A=1.8, \u03c9=1.8\"}, # Strong damping, medium frequency ] # Time range t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 1000) plt.figure(figsize=(12, 7.5)) # Solve and plot for the 5 cases for case in cases: sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(case[\"b\"], g, L, case[\"A\"], case[\"omega_d\"])) plt.plot(sol.t, sol.y[0], label=case[\"label\"]) # Formatting the plot plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.title('Forced Damped Pendulum Motion (5 Cases)') plt.legend() plt.grid(True) plt.show() Phase Portraits : \\( \\theta \\) vs. \\( \\frac{d\\theta}{dt} \\) to analyze system stability and attractors. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def forced_damped_pendulum(t, y, b, g, L, A, omega): \"\"\"ODE system for a forced damped pendulum.\"\"\" theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g/L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters g = 9.81 # Gravity (m/s\u00b2) L = 1.0 # Length of pendulum (m) y0 = [np.pi / 4, 0] # Initial angle = 45 degrees, initial velocity = 0 # Different parameter sets to compare cases = [ {\"b\": 0.2, \"A\": 1.0, \"omega\": 1.5, \"color\": \"r\", \"label\": \"b=0.2, A=1.0, \u03c9=1.5\"}, {\"b\": 0.5, \"A\": 1.2, \"omega\": 2.0, \"color\": \"b\", \"label\": \"b=0.5, A=1.2, \u03c9=2.0\"}, {\"b\": 0.8, \"A\": 1.5, \"omega\": 2.5, \"color\": \"g\", \"label\": \"b=0.8, A=1.5, \u03c9=2.5\"}, ] # Time range t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 1000) plt.figure(figsize=(12, 7.5)) # Solve and plot for different cases for case in cases: sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(case[\"b\"], g, L, case[\"A\"], case[\"omega\"])) plt.plot(sol.y[0], sol.y[1], color=case[\"color\"], label=case[\"label\"]) # Formatting plt.xlabel('Theta (angle)') plt.ylabel('Angular Velocity') plt.title('Phase Portrait of Forced Damped Pendulum') plt.legend() plt.grid(True) plt.show()","title":"Graphical Representations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"This study of the forced damped pendulum provides insight into nonlinear dynamics, resonance, and chaos, with applications in physics and engineering. By using numerical simulations, we can explore a range of behaviors from simple periodic motion to chaotic dynamics, offering deeper understanding and practical implications in various scientific domains. The forced damped pendulum serves as a fundamental model for diverse physical systems, reinforcing the significance of nonlinear dynamics in both theoretical and applied research.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Here\u2019s an edited version of the content where the derivations of Kepler\u2019s Third Law come first, before the explanation and applications: Problem 1 Orbital Period and Orbital Radius: Kepler's Third Law Derivation of Kepler's Third Law Kepler\u2019s Third Law establishes a relationship between the orbital period of a planet (or any object) and its distance from the central body it orbits. To understand how this law works, we derive it from fundamental principles of physics. 1. Gravitational Force The gravitational force acting on a planet of mass \\( m \\) , which is at a distance \\( r \\) from the central body, is given by: \\[ F_g = \\frac{GMm}{r^2} \\] Where: \\( F_g \\) is the gravitational force (in newtons), \\( G \\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\, m^3 kg^{-1} s^{-2}\\) ), \\( M \\) is the mass of the central body (in kg), \\( r \\) is the distance from the center of the central body (in meters), \\( m \\) is the mass of the orbiting object. 2. Centripetal Force The object needs a centripetal force to keep it in orbit. The centripetal force is provided by gravity, and it can be expressed as: \\[ F_c = \\frac{m v^2}{r} \\] Where: \\( F_c \\) is the centripetal force (in newtons), \\( v \\) is the orbital velocity of the object. 3. Equating the Forces For a circular orbit, the gravitational force provides the necessary centripetal force to keep the object in orbit. Therefore, we set \\( F_g = F_c \\) : \\[ \\frac{GMm}{r^2} = \\frac{m v^2}{r} \\] 4. Expressing Velocity in Terms of Orbital Period The velocity of an orbiting object is related to the orbital period \\( T \\) by the following equation: \\[ v = \\frac{2\\pi r}{T} \\] Substituting this expression for velocity into the force equation: \\[ \\frac{GMm}{r^2} = \\frac{m (2\\pi r / T)^2}{r} \\] 5. Simplifying the Equation Now, we can simplify this equation: \\[ GM = \\frac{4\\pi^2 r^3}{T^2} \\] 6. Solving for the Orbital Period Rearranging the equation to solve for the orbital period \\( T \\) , we get: \\[ T^2 = \\frac{4\\pi^2 r^3}{GM} \\] This is the modern Newtonian form of Kepler's Third Law, which states that the square of the orbital period is proportional to the cube of the orbital radius. Kepler\u2019s Third Law Kepler\u2019s Third Law provides a relationship between the orbital period \\( T \\) and the orbital radius \\( r \\) : \\[ T^2 = \\frac{4\\pi^2 r^3}{GM} \\] Where: \\( T \\) is the orbital period (in seconds), \\( r \\) is the orbital radius (in meters), \\( G \\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\, m^3 kg^{-1} s^{-2}\\) ), \\( M \\) is the mass of the central body (in kg). This equation reveals that larger orbital radii correspond to longer orbital periods , which is an important factor in understanding the motion of planets, moons, and artificial satellites. Introduction to Kepler's Laws Kepler\u2019s laws were first formulated in the early 17th century by Johannes Kepler based on the careful observations of planetary motion by Tycho Brahe . These laws describe how planets move around the Sun and how their orbital characteristics are related. Kepler's Three Laws: Kepler's Law Description First Law (Law of Ellipses) Planets move in elliptical orbits with the Sun at one focus. Second Law (Law of Equal Areas) A planet sweeps out equal areas in equal time intervals , meaning it moves faster when closer to the Sun and slower when farther. Third Law (Law of Harmonies) The square of a planet's orbital period is proportional to the cube of its orbital radius . Kepler's Third Law was empirically observed but later derived from Newton's Law of Universal Gravitation , which showed that these relationships are a natural consequence of gravitational forces. Applications in Astronomy Kepler\u2019s Third Law is useful in various fields, including astronomy, space exploration, and satellite motion: 1. Determining Planetary Masses By measuring the orbital period and distance of a planet\u2019s moon, we can calculate the mass of the planet using: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] For example, the mass of Earth can be determined by analyzing the Moon\u2019s orbit. 2. Satellite Motion Engineers use Kepler\u2019s Third Law to design satellites and space stations. By selecting the appropriate altitude, they can ensure stable orbits for satellites such as GPS and communication satellites. Satellite Orbital Radius (km) Orbital Period (hours) GPS 26,600 12 Geostationary 42,164 24 Hubble Space Telescope 6,978 1.5 3. Exoplanet Discovery Astronomers detect exoplanets by measuring the dimming of stars due to planetary transits. Using Kepler\u2019s Third Law, they estimate the planet\u2019s distance from its star and deduce whether it lies in the habitable zone . Exoplanet Orbital Radius (AU) Orbital Period (Days) Kepler-22b 0.85 290 Proxima Centauri b 0.05 11.2 51 Pegasi b 0.05 4.2 4. Comparing Different Orbital Systems Kepler\u2019s Law helps compare planetary orbits in different star systems and allows astronomers to analyze binary star systems. The Solar System and Kepler\u2019s Law The following table lists the orbital radius and period of major planets in the Solar System, illustrating Kepler\u2019s Third Law. Planet Orbital Radius (AU) Orbital Period (Years) \\(T^2\\) \\(r^3\\) Mercury 0.39 0.24 0.0576 0.0593 Venus 0.72 0.62 0.3844 0.3732 Earth 1.00 1.00 1.0000 1.0000 Mars 1.52 1.88 3.5344 3.5123 Jupiter 5.20 11.86 140.6596 140.6080 Saturn 9.58 29.46 867.0916 881.1824 The values for \\( T^2 \\) and \\( r^3 \\) confirm the proportional relationship predicted by Kepler's Third Law . Conclusion Kepler\u2019s Third Law provides a crucial link between gravity and orbital motion . It extends beyond planets and applies to moons, artificial satellites, and even binary star systems . By analyzing Kepler\u2019s Third Law, astronomers can determine planetary masses, satellite trajectories, and the structure of distant star systems. Implementation in Python The following Python script computes orbital periods for different celestial bodies and visualizes the relationship. import numpy as np import matplotlib.pyplot as plt def keplers_third_law(G, M, radii): \"\"\" Computes the orbital periods based on Kepler's Third Law: T^2 = (4\u03c0^2 * r^3) / (G * M) Parameters: G : float : Gravitational constant (m^3 kg^-1 s^-2) M : float : Mass of the central body (kg) radii : array : Orbital radii (m) Returns: periods : array : Orbital periods (s) \"\"\" return np.sqrt((4 * np.pi**2 * radii**3) / (G * M)) # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) M_sun = 1.989e30 # Mass of Sun (kg) # Orbital radii (in meters) radii = np.array([ 3.844e8, # Moon around Earth 1.496e11, # Earth around Sun 2.279e11, # Mars around Sun 7.785e11 # Jupiter around Sun ]) # Compute periods periods_earth = keplers_third_law(G, M_earth, radii[:1]) # Moon orbiting Earth periods_sun = keplers_third_law(G, M_sun, radii[1:]) # Planets orbiting the Sun # Convert seconds to days periods_earth_days = periods_earth / (60 * 60 * 24) periods_sun_days = periods_sun / (60 * 60 * 24) # Print computed values in table format print(f\"{'Celestial Body':<20}{'Orbital Radius (m)':<25}{'Orbital Period (days)':<25}\") print(\"-\" * 70) celestial_bodies = [\"Moon (around Earth)\", \"Earth (around Sun)\", \"Mars (around Sun)\", \"Jupiter (around Sun)\"] all_periods = np.concatenate([periods_earth_days, periods_sun_days]) for i in range(len(radii)): print(f\"{celestial_bodies[i]:<20}{radii[i]:<25.3e}{all_periods[i]:<25.3f}\") # Plot results radii_plot = np.linspace(1e7, 3e12, 100) # Extended range of radii periods_plot_earth = keplers_third_law(G, M_earth, radii_plot) periods_plot_sun = keplers_third_law(G, M_sun, radii_plot) plt.figure(figsize=(12, 7.5)) plt.loglog(radii_plot, periods_plot_earth / (60 * 60 * 24), label='Moon around Earth', linestyle='dashed') plt.loglog(radii_plot, periods_plot_sun / (60 * 60 * 24), label='Planets around Sun', linestyle='solid') plt.scatter(radii, all_periods, color='red', zorder=3, label='Real Data') # Add annotations for clarity for i, txt in enumerate(celestial_bodies): plt.annotate(txt, (radii[i], all_periods[i]), textcoords=\"offset points\", xytext=(10,-10), ha='left') # Improve axis labels plt.xlabel('Orbital Radius (m)', fontsize=12) plt.ylabel('Orbital Period (days)', fontsize=12) plt.title(\"Kepler's Third Law: Period vs Radius\", fontsize=14) plt.legend() plt.grid(True, which='both', linestyle='--', linewidth=0.5) plt.show()","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius-keplers-third-law","text":"","title":"Orbital Period and Orbital Radius: Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law","text":"Kepler\u2019s Third Law establishes a relationship between the orbital period of a planet (or any object) and its distance from the central body it orbits. To understand how this law works, we derive it from fundamental principles of physics.","title":"Derivation of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-gravitational-force","text":"The gravitational force acting on a planet of mass \\( m \\) , which is at a distance \\( r \\) from the central body, is given by: \\[ F_g = \\frac{GMm}{r^2} \\] Where: \\( F_g \\) is the gravitational force (in newtons), \\( G \\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\, m^3 kg^{-1} s^{-2}\\) ), \\( M \\) is the mass of the central body (in kg), \\( r \\) is the distance from the center of the central body (in meters), \\( m \\) is the mass of the orbiting object.","title":"1. Gravitational Force"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-centripetal-force","text":"The object needs a centripetal force to keep it in orbit. The centripetal force is provided by gravity, and it can be expressed as: \\[ F_c = \\frac{m v^2}{r} \\] Where: \\( F_c \\) is the centripetal force (in newtons), \\( v \\) is the orbital velocity of the object.","title":"2. Centripetal Force"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-equating-the-forces","text":"For a circular orbit, the gravitational force provides the necessary centripetal force to keep the object in orbit. Therefore, we set \\( F_g = F_c \\) : \\[ \\frac{GMm}{r^2} = \\frac{m v^2}{r} \\]","title":"3. Equating the Forces"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-expressing-velocity-in-terms-of-orbital-period","text":"The velocity of an orbiting object is related to the orbital period \\( T \\) by the following equation: \\[ v = \\frac{2\\pi r}{T} \\] Substituting this expression for velocity into the force equation: \\[ \\frac{GMm}{r^2} = \\frac{m (2\\pi r / T)^2}{r} \\]","title":"4. Expressing Velocity in Terms of Orbital Period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-simplifying-the-equation","text":"Now, we can simplify this equation: \\[ GM = \\frac{4\\pi^2 r^3}{T^2} \\]","title":"5. Simplifying the Equation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#6-solving-for-the-orbital-period","text":"Rearranging the equation to solve for the orbital period \\( T \\) , we get: \\[ T^2 = \\frac{4\\pi^2 r^3}{GM} \\] This is the modern Newtonian form of Kepler's Third Law, which states that the square of the orbital period is proportional to the cube of the orbital radius.","title":"6. Solving for the Orbital Period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law","text":"Kepler\u2019s Third Law provides a relationship between the orbital period \\( T \\) and the orbital radius \\( r \\) : \\[ T^2 = \\frac{4\\pi^2 r^3}{GM} \\] Where: \\( T \\) is the orbital period (in seconds), \\( r \\) is the orbital radius (in meters), \\( G \\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\, m^3 kg^{-1} s^{-2}\\) ), \\( M \\) is the mass of the central body (in kg). This equation reveals that larger orbital radii correspond to longer orbital periods , which is an important factor in understanding the motion of planets, moons, and artificial satellites.","title":"Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#introduction-to-keplers-laws","text":"Kepler\u2019s laws were first formulated in the early 17th century by Johannes Kepler based on the careful observations of planetary motion by Tycho Brahe . These laws describe how planets move around the Sun and how their orbital characteristics are related.","title":"Introduction to Kepler's Laws"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-three-laws","text":"Kepler's Law Description First Law (Law of Ellipses) Planets move in elliptical orbits with the Sun at one focus. Second Law (Law of Equal Areas) A planet sweeps out equal areas in equal time intervals , meaning it moves faster when closer to the Sun and slower when farther. Third Law (Law of Harmonies) The square of a planet's orbital period is proportional to the cube of its orbital radius . Kepler's Third Law was empirically observed but later derived from Newton's Law of Universal Gravitation , which showed that these relationships are a natural consequence of gravitational forces.","title":"Kepler's Three Laws:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#applications-in-astronomy","text":"Kepler\u2019s Third Law is useful in various fields, including astronomy, space exploration, and satellite motion:","title":"Applications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-determining-planetary-masses","text":"By measuring the orbital period and distance of a planet\u2019s moon, we can calculate the mass of the planet using: \\[ M = \\frac{4\\pi^2 r^3}{G T^2} \\] For example, the mass of Earth can be determined by analyzing the Moon\u2019s orbit.","title":"1. Determining Planetary Masses"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-satellite-motion","text":"Engineers use Kepler\u2019s Third Law to design satellites and space stations. By selecting the appropriate altitude, they can ensure stable orbits for satellites such as GPS and communication satellites. Satellite Orbital Radius (km) Orbital Period (hours) GPS 26,600 12 Geostationary 42,164 24 Hubble Space Telescope 6,978 1.5","title":"2. Satellite Motion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-exoplanet-discovery","text":"Astronomers detect exoplanets by measuring the dimming of stars due to planetary transits. Using Kepler\u2019s Third Law, they estimate the planet\u2019s distance from its star and deduce whether it lies in the habitable zone . Exoplanet Orbital Radius (AU) Orbital Period (Days) Kepler-22b 0.85 290 Proxima Centauri b 0.05 11.2 51 Pegasi b 0.05 4.2","title":"3. Exoplanet Discovery"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-comparing-different-orbital-systems","text":"Kepler\u2019s Law helps compare planetary orbits in different star systems and allows astronomers to analyze binary star systems.","title":"4. Comparing Different Orbital Systems"},{"location":"1%20Physics/2%20Gravity/Problem_1/#the-solar-system-and-keplers-law","text":"The following table lists the orbital radius and period of major planets in the Solar System, illustrating Kepler\u2019s Third Law. Planet Orbital Radius (AU) Orbital Period (Years) \\(T^2\\) \\(r^3\\) Mercury 0.39 0.24 0.0576 0.0593 Venus 0.72 0.62 0.3844 0.3732 Earth 1.00 1.00 1.0000 1.0000 Mars 1.52 1.88 3.5344 3.5123 Jupiter 5.20 11.86 140.6596 140.6080 Saturn 9.58 29.46 867.0916 881.1824 The values for \\( T^2 \\) and \\( r^3 \\) confirm the proportional relationship predicted by Kepler's Third Law .","title":"The Solar System and Kepler\u2019s Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler\u2019s Third Law provides a crucial link between gravity and orbital motion . It extends beyond planets and applies to moons, artificial satellites, and even binary star systems . By analyzing Kepler\u2019s Third Law, astronomers can determine planetary masses, satellite trajectories, and the structure of distant star systems.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implementation-in-python","text":"The following Python script computes orbital periods for different celestial bodies and visualizes the relationship. import numpy as np import matplotlib.pyplot as plt def keplers_third_law(G, M, radii): \"\"\" Computes the orbital periods based on Kepler's Third Law: T^2 = (4\u03c0^2 * r^3) / (G * M) Parameters: G : float : Gravitational constant (m^3 kg^-1 s^-2) M : float : Mass of the central body (kg) radii : array : Orbital radii (m) Returns: periods : array : Orbital periods (s) \"\"\" return np.sqrt((4 * np.pi**2 * radii**3) / (G * M)) # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) M_sun = 1.989e30 # Mass of Sun (kg) # Orbital radii (in meters) radii = np.array([ 3.844e8, # Moon around Earth 1.496e11, # Earth around Sun 2.279e11, # Mars around Sun 7.785e11 # Jupiter around Sun ]) # Compute periods periods_earth = keplers_third_law(G, M_earth, radii[:1]) # Moon orbiting Earth periods_sun = keplers_third_law(G, M_sun, radii[1:]) # Planets orbiting the Sun # Convert seconds to days periods_earth_days = periods_earth / (60 * 60 * 24) periods_sun_days = periods_sun / (60 * 60 * 24) # Print computed values in table format print(f\"{'Celestial Body':<20}{'Orbital Radius (m)':<25}{'Orbital Period (days)':<25}\") print(\"-\" * 70) celestial_bodies = [\"Moon (around Earth)\", \"Earth (around Sun)\", \"Mars (around Sun)\", \"Jupiter (around Sun)\"] all_periods = np.concatenate([periods_earth_days, periods_sun_days]) for i in range(len(radii)): print(f\"{celestial_bodies[i]:<20}{radii[i]:<25.3e}{all_periods[i]:<25.3f}\") # Plot results radii_plot = np.linspace(1e7, 3e12, 100) # Extended range of radii periods_plot_earth = keplers_third_law(G, M_earth, radii_plot) periods_plot_sun = keplers_third_law(G, M_sun, radii_plot) plt.figure(figsize=(12, 7.5)) plt.loglog(radii_plot, periods_plot_earth / (60 * 60 * 24), label='Moon around Earth', linestyle='dashed') plt.loglog(radii_plot, periods_plot_sun / (60 * 60 * 24), label='Planets around Sun', linestyle='solid') plt.scatter(radii, all_periods, color='red', zorder=3, label='Real Data') # Add annotations for clarity for i, txt in enumerate(celestial_bodies): plt.annotate(txt, (radii[i], all_periods[i]), textcoords=\"offset points\", xytext=(10,-10), ha='left') # Improve axis labels plt.xlabel('Orbital Radius (m)', fontsize=12) plt.ylabel('Orbital Period (days)', fontsize=12) plt.title(\"Kepler's Third Law: Period vs Radius\", fontsize=14) plt.legend() plt.grid(True, which='both', linestyle='--', linewidth=0.5) plt.show()","title":"Implementation in Python"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Introduction The concept of escape velocity is a fundamental idea in orbital mechanics, representing the minimum velocity required for an object to break free from a celestial body's gravitational pull without further propulsion. Alongside this, the cosmic velocities define different thresholds that mark the boundaries for various stages of escape and orbiting in a gravitational system. In this document, we explore the first, second, and third cosmic velocities , the equations governing them, and their importance in space exploration. These velocities provide the necessary guidelines for launching satellites, interplanetary missions, and even future interstellar travel. The Three Cosmic Velocities First Cosmic Velocity (Orbital Velocity) : The speed required for an object to stay in a stable orbit around a celestial body. This is the velocity at which an object must travel to balance the gravitational pull with the centrifugal force. Second Cosmic Velocity (Escape Velocity) : The speed needed for an object to escape a celestial body's gravitational influence. This velocity ensures that the object can move away from the body indefinitely, without falling back. Third Cosmic Velocity (Solar Escape Velocity) : The velocity required for an object to escape the gravitational influence of the Sun (or another central star) and enter interstellar space. Derivation of Cosmic Velocities 1. First Cosmic Velocity (Orbital Velocity) The first cosmic velocity is the orbital velocity that an object must achieve to stay in a circular orbit around a celestial body. This can be derived by equating the gravitational force ( \\(F_{\\text{gravity}}\\) ) to the centripetal force ( \\(F_{\\text{centripetal}}\\) ) acting on the object. The gravitational force is: \\[ F_{\\text{gravity}} = \\frac{GMm}{r^2} \\] The centripetal force required for circular motion is: \\[ F_{\\text{centripetal}} = \\frac{mv^2}{r} \\] Where: \\(G\\) is the gravitational constant, \\(M\\) is the mass of the celestial body, \\(m\\) is the mass of the orbiting object, \\(r\\) is the orbital radius (distance from the center of the celestial body), \\(v\\) is the orbital velocity. Equating the two forces: \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] After simplifying, we find the formula for the first cosmic velocity : \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] Where: \\(v_1\\) is the first cosmic velocity, \\(M\\) is the mass of the central celestial body, \\(r\\) is the orbital radius (distance from the center of the celestial body). 2. Second Cosmic Velocity (Escape Velocity) The second cosmic velocity is the escape velocity required to break free from the gravitational pull of a celestial body. This is derived from the energy principle, where the total mechanical energy of the object (kinetic energy + potential energy) must be zero for the object to escape. The gravitational potential energy is given by: \\[ E_{\\text{potential}} = -\\frac{GMm}{r} \\] The kinetic energy required for escape is: \\[ E_{\\text{kinetic}} = \\frac{1}{2}mv^2 \\] For escape, the total energy should be zero, so: \\[ \\frac{1}{2}mv_2^2 = \\frac{GMm}{r} \\] Solving for \\(v_2\\) , the escape velocity : \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] Where: \\(v_2\\) is the second cosmic velocity, \\(M\\) is the mass of the celestial body, \\(r\\) is the radial distance from the center of the body. 3. Third Cosmic Velocity (Solar Escape Velocity) The third cosmic velocity is the velocity needed for an object to escape the gravitational influence of the Sun (or any other central star) and travel into interstellar space. The escape velocity from the Sun can be derived similarly to the second cosmic velocity, but with the Sun's mass as the central body. The third cosmic velocity is given by: \\[ v_3 = \\sqrt{\\frac{2GM_{\\text{sun}}}{r}} \\] Where: \\(v_3\\) is the third cosmic velocity, \\(M_{\\text{sun}}\\) is the mass of the Sun (or the mass of another central star), \\(r\\) is the distance from the Sun (or the central star). Cosmic Velocities for Different Celestial Bodies Table 1: Velocities for Earth, Mars, and Jupiter The following table summarizes the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. Celestial Body Orbital Radius (m) First Cosmic Velocity (v\u2081) [m/s] Second Cosmic Velocity (v\u2082) [m/s] Third Cosmic Velocity (v\u2083) [m/s] Earth 6.371 \u00d7 10\u2076 7.12 \u00d7 10\u00b3 1.12 \u00d7 10\u2074 6.26 \u00d7 10\u2074 Mars 3.396 \u00d7 10\u2076 5.40 \u00d7 10\u00b3 9.51 \u00d7 10\u00b3 N/A Jupiter 6.991 \u00d7 10\u2077 1.29 \u00d7 10\u2074 1.83 \u00d7 10\u2074 N/A Python Code for Calculating and Visualizing Velocities Below is the Python code that calculates the first, second, and third cosmic velocities for various celestial bodies, including Earth, Mars, and Jupiter. It also visualizes these velocities using a bar chart. Learn more. import numpy as np import matplotlib.pyplot as plt def first_cosmic_velocity(G, M, r): \"\"\" Calculates the first cosmic velocity (orbital velocity). Parameters: G : float : Gravitational constant (m^3 kg^-1 s^-2) M : float : Mass of the celestial body (kg) r : float : Orbital radius (m) Returns: float : First cosmic velocity (m/s) \"\"\" return np.sqrt(G * M / r) def second_cosmic_velocity(G, M, r): \"\"\" Calculates the second cosmic velocity (escape velocity). Parameters: G : float : Gravitational constant (m^3 kg^-1 s^-2) M : float : Mass of the celestial body (kg) r : float : Orbital radius (m) Returns: float : Second cosmic velocity (m/s) \"\"\" return np.sqrt(2 * G * M / r) def third_cosmic_velocity(G, M_sun, r): \"\"\" Calculates the third cosmic velocity (velocity to escape the solar system). Parameters: G : float : Gravitational constant (m^3 kg^-1 s^-2) M_sun : float : Mass of the Sun (kg) r : float : Distance from the Sun (m) Returns: float : Third cosmic velocity (m/s) \"\"\" return np.sqrt(2 * G * M_sun / r) # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) M_mars = 6.4171e23 # Mass of Mars (kg) M_jupiter = 1.8982e27 # Mass of Jupiter (kg) M_sun = 1.989e30 # Mass of Sun (kg) # Radii (in meters) radii_earth = 6.371e6 # Radius of Earth (m) radii_mars = 3.396e6 # Radius of Mars (m) radii_jupiter = 6.991e7 # Radius of Jupiter (m) distance_sun_earth = 1.496e11 # Distance from Earth to Sun (m) # Compute cosmic velocities v1_earth = first_cosmic_velocity(G, M_earth, radii_earth) v2_earth = second_cosmic_velocity(G, M_earth, radii_earth) v3_earth = third_cosmic_velocity(G, M_sun, distance_sun_earth) v1_mars = first_cosmic_velocity(G, M_mars, radii_mars) v2_mars = second_cosmic_velocity(G, M_mars, radii_mars) v3_mars = third_cosmic_velocity(G, M_sun, distance_sun_earth) # Mars's escape from Sun v1_jupiter = first_cosmic_velocity(G, M_jupiter, radii_jupiter) v2_jupiter = second_cosmic_velocity(G, M_jupiter, radii_jupiter) v3_jupiter = third_cosmic_velocity(G, M_sun, distance_sun_earth) # Jupiter's escape from Sun # Output the velocities for each body print(f\"{'Celestial Body':<20}{'v1 (Orbital Velocity) [m/s]':<30}{'v2 (Escape Velocity) [m/s]':<30}{'v3 (Solar Escape Velocity) [m/s]':<30}\") print(\"-\" * 110) bodies = [\"Earth\", \"Mars\", \"Jupiter\"] velocities = [ (v1_earth, v2_earth, v3_earth), (v1_mars, v2_mars, v3_mars), (v1_jupiter, v2_jupiter, v3_jupiter) ] for i, body in enumerate(bodies): v3_val = velocities[i][2] if velocities[i][2] else \"N/A\" print(f\"{body:<20}{velocities[i][0]:<30.2f}{velocities[i][1]:<30.2f}{v3_val:<30}\") # Plot the velocities labels = [\"Orbital Velocity (v1)\", \"Escape Velocity (v2)\", \"Solar Escape Velocity (v3)\"] # Prepare data for plotting velocities_data = np.array([[ velocities[0][0], velocities[0][1], velocities[0][2]], [velocities[1][0], velocities[1][1], velocities[1][2]], [velocities[2][0], velocities[2][1], velocities[2][2]] ]) fig, ax = plt.subplots(figsize=(12, 7.5)) bar_width = 0.25 index = np.arange(len(bodies)) # Plot the bars bar1 = ax.bar(index - bar_width, velocities_data[:, 0], bar_width, label=labels[0]) bar2 = ax.bar(index, velocities_data[:, 1], bar_width, label=labels[1]) bar3 = ax.bar(index + bar_width, velocities_data[:, 2], bar_width, label=labels[2]) ax.set_xlabel('Celestial Bodies') ax.set_ylabel('Velocity (m/s)') ax.set_title('Cosmic Velocities for Different Celestial Bodies') ax.set_xticks(index) ax.set_xticklabels(bodies) ax.legend() plt.tight_layout() plt.show()","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#introduction","text":"The concept of escape velocity is a fundamental idea in orbital mechanics, representing the minimum velocity required for an object to break free from a celestial body's gravitational pull without further propulsion. Alongside this, the cosmic velocities define different thresholds that mark the boundaries for various stages of escape and orbiting in a gravitational system. In this document, we explore the first, second, and third cosmic velocities , the equations governing them, and their importance in space exploration. These velocities provide the necessary guidelines for launching satellites, interplanetary missions, and even future interstellar travel.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#the-three-cosmic-velocities","text":"First Cosmic Velocity (Orbital Velocity) : The speed required for an object to stay in a stable orbit around a celestial body. This is the velocity at which an object must travel to balance the gravitational pull with the centrifugal force. Second Cosmic Velocity (Escape Velocity) : The speed needed for an object to escape a celestial body's gravitational influence. This velocity ensures that the object can move away from the body indefinitely, without falling back. Third Cosmic Velocity (Solar Escape Velocity) : The velocity required for an object to escape the gravitational influence of the Sun (or another central star) and enter interstellar space.","title":"The Three Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#derivation-of-cosmic-velocities","text":"","title":"Derivation of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-orbital-velocity","text":"The first cosmic velocity is the orbital velocity that an object must achieve to stay in a circular orbit around a celestial body. This can be derived by equating the gravitational force ( \\(F_{\\text{gravity}}\\) ) to the centripetal force ( \\(F_{\\text{centripetal}}\\) ) acting on the object. The gravitational force is: \\[ F_{\\text{gravity}} = \\frac{GMm}{r^2} \\] The centripetal force required for circular motion is: \\[ F_{\\text{centripetal}} = \\frac{mv^2}{r} \\] Where: \\(G\\) is the gravitational constant, \\(M\\) is the mass of the celestial body, \\(m\\) is the mass of the orbiting object, \\(r\\) is the orbital radius (distance from the center of the celestial body), \\(v\\) is the orbital velocity. Equating the two forces: \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] After simplifying, we find the formula for the first cosmic velocity : \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] Where: \\(v_1\\) is the first cosmic velocity, \\(M\\) is the mass of the central celestial body, \\(r\\) is the orbital radius (distance from the center of the celestial body).","title":"1. First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity","text":"The second cosmic velocity is the escape velocity required to break free from the gravitational pull of a celestial body. This is derived from the energy principle, where the total mechanical energy of the object (kinetic energy + potential energy) must be zero for the object to escape. The gravitational potential energy is given by: \\[ E_{\\text{potential}} = -\\frac{GMm}{r} \\] The kinetic energy required for escape is: \\[ E_{\\text{kinetic}} = \\frac{1}{2}mv^2 \\] For escape, the total energy should be zero, so: \\[ \\frac{1}{2}mv_2^2 = \\frac{GMm}{r} \\] Solving for \\(v_2\\) , the escape velocity : \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] Where: \\(v_2\\) is the second cosmic velocity, \\(M\\) is the mass of the celestial body, \\(r\\) is the radial distance from the center of the body.","title":"2. Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-solar-escape-velocity","text":"The third cosmic velocity is the velocity needed for an object to escape the gravitational influence of the Sun (or any other central star) and travel into interstellar space. The escape velocity from the Sun can be derived similarly to the second cosmic velocity, but with the Sun's mass as the central body. The third cosmic velocity is given by: \\[ v_3 = \\sqrt{\\frac{2GM_{\\text{sun}}}{r}} \\] Where: \\(v_3\\) is the third cosmic velocity, \\(M_{\\text{sun}}\\) is the mass of the Sun (or the mass of another central star), \\(r\\) is the distance from the Sun (or the central star).","title":"3. Third Cosmic Velocity (Solar Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocities-for-different-celestial-bodies","text":"","title":"Cosmic Velocities for Different Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#table-1-velocities-for-earth-mars-and-jupiter","text":"The following table summarizes the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. Celestial Body Orbital Radius (m) First Cosmic Velocity (v\u2081) [m/s] Second Cosmic Velocity (v\u2082) [m/s] Third Cosmic Velocity (v\u2083) [m/s] Earth 6.371 \u00d7 10\u2076 7.12 \u00d7 10\u00b3 1.12 \u00d7 10\u2074 6.26 \u00d7 10\u2074 Mars 3.396 \u00d7 10\u2076 5.40 \u00d7 10\u00b3 9.51 \u00d7 10\u00b3 N/A Jupiter 6.991 \u00d7 10\u2077 1.29 \u00d7 10\u2074 1.83 \u00d7 10\u2074 N/A","title":"Table 1: Velocities for Earth, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code-for-calculating-and-visualizing-velocities","text":"Below is the Python code that calculates the first, second, and third cosmic velocities for various celestial bodies, including Earth, Mars, and Jupiter. It also visualizes these velocities using a bar chart. Learn more. import numpy as np import matplotlib.pyplot as plt def first_cosmic_velocity(G, M, r): \"\"\" Calculates the first cosmic velocity (orbital velocity). Parameters: G : float : Gravitational constant (m^3 kg^-1 s^-2) M : float : Mass of the celestial body (kg) r : float : Orbital radius (m) Returns: float : First cosmic velocity (m/s) \"\"\" return np.sqrt(G * M / r) def second_cosmic_velocity(G, M, r): \"\"\" Calculates the second cosmic velocity (escape velocity). Parameters: G : float : Gravitational constant (m^3 kg^-1 s^-2) M : float : Mass of the celestial body (kg) r : float : Orbital radius (m) Returns: float : Second cosmic velocity (m/s) \"\"\" return np.sqrt(2 * G * M / r) def third_cosmic_velocity(G, M_sun, r): \"\"\" Calculates the third cosmic velocity (velocity to escape the solar system). Parameters: G : float : Gravitational constant (m^3 kg^-1 s^-2) M_sun : float : Mass of the Sun (kg) r : float : Distance from the Sun (m) Returns: float : Third cosmic velocity (m/s) \"\"\" return np.sqrt(2 * G * M_sun / r) # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) M_mars = 6.4171e23 # Mass of Mars (kg) M_jupiter = 1.8982e27 # Mass of Jupiter (kg) M_sun = 1.989e30 # Mass of Sun (kg) # Radii (in meters) radii_earth = 6.371e6 # Radius of Earth (m) radii_mars = 3.396e6 # Radius of Mars (m) radii_jupiter = 6.991e7 # Radius of Jupiter (m) distance_sun_earth = 1.496e11 # Distance from Earth to Sun (m) # Compute cosmic velocities v1_earth = first_cosmic_velocity(G, M_earth, radii_earth) v2_earth = second_cosmic_velocity(G, M_earth, radii_earth) v3_earth = third_cosmic_velocity(G, M_sun, distance_sun_earth) v1_mars = first_cosmic_velocity(G, M_mars, radii_mars) v2_mars = second_cosmic_velocity(G, M_mars, radii_mars) v3_mars = third_cosmic_velocity(G, M_sun, distance_sun_earth) # Mars's escape from Sun v1_jupiter = first_cosmic_velocity(G, M_jupiter, radii_jupiter) v2_jupiter = second_cosmic_velocity(G, M_jupiter, radii_jupiter) v3_jupiter = third_cosmic_velocity(G, M_sun, distance_sun_earth) # Jupiter's escape from Sun # Output the velocities for each body print(f\"{'Celestial Body':<20}{'v1 (Orbital Velocity) [m/s]':<30}{'v2 (Escape Velocity) [m/s]':<30}{'v3 (Solar Escape Velocity) [m/s]':<30}\") print(\"-\" * 110) bodies = [\"Earth\", \"Mars\", \"Jupiter\"] velocities = [ (v1_earth, v2_earth, v3_earth), (v1_mars, v2_mars, v3_mars), (v1_jupiter, v2_jupiter, v3_jupiter) ] for i, body in enumerate(bodies): v3_val = velocities[i][2] if velocities[i][2] else \"N/A\" print(f\"{body:<20}{velocities[i][0]:<30.2f}{velocities[i][1]:<30.2f}{v3_val:<30}\") # Plot the velocities labels = [\"Orbital Velocity (v1)\", \"Escape Velocity (v2)\", \"Solar Escape Velocity (v3)\"] # Prepare data for plotting velocities_data = np.array([[ velocities[0][0], velocities[0][1], velocities[0][2]], [velocities[1][0], velocities[1][1], velocities[1][2]], [velocities[2][0], velocities[2][1], velocities[2][2]] ]) fig, ax = plt.subplots(figsize=(12, 7.5)) bar_width = 0.25 index = np.arange(len(bodies)) # Plot the bars bar1 = ax.bar(index - bar_width, velocities_data[:, 0], bar_width, label=labels[0]) bar2 = ax.bar(index, velocities_data[:, 1], bar_width, label=labels[1]) bar3 = ax.bar(index + bar_width, velocities_data[:, 2], bar_width, label=labels[2]) ax.set_xlabel('Celestial Bodies') ax.set_ylabel('Velocity (m/s)') ax.set_title('Cosmic Velocities for Different Celestial Bodies') ax.set_xticks(index) ax.set_xticklabels(bodies) ax.legend() plt.tight_layout() plt.show()","title":"Python Code for Calculating and Visualizing Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Introduction When a payload is released from a moving rocket near Earth, its trajectory depends on various factors such as its initial velocity, position, and the gravitational forces it experiences. Depending on these initial conditions, the payload can follow different types of trajectories such as elliptical, parabolic, or hyperbolic. These trajectories are critical for space missions, including satellite deployment, payload recovery, and even interplanetary travel. Understanding the different trajectories that a payload can follow, based on its velocity and position relative to Earth, is essential for mission planning. This document discusses the underlying physics of gravitational forces, derives the equations of motion, explains the types of possible trajectories, and provides a simulation of a payload's trajectory near Earth. Gravitational Force and Equations of Motion The motion of a payload near Earth is governed by Newton\u2019s law of gravitation. The gravitational force acting on an object of mass \\(m\\) at a distance \\(r\\) from the center of Earth is given by: \\[ F = \\frac{GMm}{r^2} \\] Where: \\(F\\) is the gravitational force (in newtons), \\(G\\) is the gravitational constant, \\(6.67430 \\times 10^{-11}\\) m\u00b3/kg\u22c5s\u00b2, \\(M\\) is the mass of Earth ( \\(5.972 \\times 10^{24}\\) kg), \\(m\\) is the mass of the payload, \\(r\\) is the distance from the center of Earth to the payload (in meters). The force is responsible for the acceleration of the payload towards Earth. The acceleration \\(a\\) is given by: \\[ a = \\frac{F}{m} = \\frac{GM}{r^2} \\] This is also referred to as gravitational acceleration . The second-order differential equations describing the motion of an object under Earth's gravity are: \\[ \\frac{d^2 x}{dt^2} = -\\frac{GM x}{(x^2 + y^2)^{3/2}}, \\quad \\frac{d^2 y}{dt^2} = -\\frac{GM y}{(x^2 + y^2)^{3/2}} \\] These equations form the foundation for calculating the trajectory of the payload. Additional Mathematical Computations Let's now expand on the motion using a specific example to compute the initial velocities and energy in different scenarios: Escape Velocity Computation The escape velocity at a given distance \\(r\\) from the center of Earth is given by: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] At Earth's surface, \\(r = R_{\\text{Earth}} = 6.371 \\times 10^6\\) m: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2 \\times 6.67430 \\times 10^{-11} \\times 5.972 \\times 10^{24}}{6.371 \\times 10^6}} \\approx 11200 \\, \\text{m/s} \\] Energy Conservation in Gravitational Motion For a payload, the total mechanical energy is conserved in the absence of other forces. The total energy \\(E\\) is the sum of the kinetic and potential energies: \\[ E = \\frac{1}{2} m v^2 - \\frac{GMm}{r} \\] Where: \\(v\\) is the velocity of the payload, \\(r\\) is the distance from the center of Earth. For different initial velocities, we compute the total energy: For a payload at \\(r = 2 \\times R_{\\text{Earth}}\\) with an initial velocity of \\(v_0 = 9000 \\, \\text{m/s}\\) : \\[ E = \\frac{1}{2} m (9000)^2 - \\frac{GMm}{2R_{\\text{Earth}}} \\] This can be expanded for different scenarios as part of a trajectory analysis. Types of Trajectories The trajectory of a payload released near Earth depends on its initial velocity. Based on the velocity, the trajectory could be one of the following: 1. Elliptical Trajectory When the initial velocity is less than the escape velocity, the payload follows an elliptical trajectory. The payload will eventually return to Earth after completing its elliptical orbit. This type of trajectory is typical for satellites in low Earth orbit (LEO). The general equation for an elliptical orbit is derived from Kepler's Laws: \\[ r(t) = \\frac{a(1 - e^2)}{1 + e \\cos(\\theta)} \\] Where: \\(a\\) is the semi-major axis, \\(e\\) is the orbital eccentricity, \\(\\theta\\) is the true anomaly (the angle between the payload and the periapsis). 2. Parabolic Trajectory When the payload's initial velocity is equal to the escape velocity at a given distance from Earth, its trajectory will be parabolic. A parabolic trajectory is the boundary between bound and unbound motion, and it represents the exact condition for escaping Earth's gravity. 3. Hyperbolic Trajectory If the payload's initial velocity exceeds the escape velocity, the trajectory will be hyperbolic. In this case, the payload escapes Earth's gravitational influence completely, traveling on a path that takes it far beyond Earth. Numerical Simulation of Trajectories To simulate the trajectory of a payload under the influence of Earth\u2019s gravity, we use numerical methods, particularly Runge-Kutta and adaptive solvers to solve the equations of motion. Below is an extended version of the code with multiple scenarios and further mathematical computations. Learn more here . import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # m\u00b3/kg/s\u00b2 M_earth = 5.972e24 # kg R_earth = 6.371e6 # m def equations(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M_earth * x / r**3 ay = -G * M_earth * y / r**3 return [vx, vy, ax, ay] def simulate_trajectory(y0, t_max, solver='RK45'): t_span = (0, t_max) t_eval = np.linspace(0, t_max, 2000) sol = solve_ivp(equations, t_span, y0, t_eval=t_eval, method=solver, rtol=1e-8) return sol # Different scenarios for simulation scenarios = { \"LEO (Circular Orbit)\": [R_earth + 300e3, 0, 0, 7800], # LEO example \"Suborbital\": [R_earth + 100e3, 0, 0, 5000], # Suborbital trajectory \"Escape Trajectory\": [R_earth + 300e3, 0, 0, 11200], # Escape velocity \"Hyperbolic Escape\": [R_earth + 300e3, 0, 0, 12000] # Hyperbolic trajectory } # Visualize the trajectories plt.figure(figsize=(12, 12)) for label, initial_conditions in scenarios.items(): sol = simulate_trajectory(initial_conditions, 5000) plt.plot(sol.y[0], sol.y[1], label=label) plt.scatter(0, 0, color='red', label='Earth Center') plt.xlabel(\"X Position (m)\") plt.ylabel(\"Y Position (m)\") plt.legend() plt.grid() plt.title(\"Different Trajectories of a Released Payload\") plt.show() Additional Example: Calculation of Energy To further illustrate the differences in energy at various positions, consider the following energy calculation for a payload with initial velocity \\(v_0 = 9000 \\, \\text{m/s}\\) at \\(r = 2 \\times R_{\\text{Earth}}\\) : Compute the total mechanical energy: \\[ E = \\frac{1}{2} m v_0^2 - \\frac{GMm}{r} \\] For \\(v_0 = 9000 \\, \\text{m/s}\\) and \\(r = 2R_{\\text{Earth}}\\) : \\[ E = \\frac{1}{2} m (9000)^2 - \\frac{G M m}{2R_{\\text{Earth}}} \\] Conclusion This study explored payload trajectories mathematically and computationally, deriving governing equations, implementing numerical solutions with improved accuracy, and providing multiple examples. These additional mathematical calculations, including energy considerations and velocity computations, provide further insight into how different initial conditions affect the trajectory.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#introduction","text":"When a payload is released from a moving rocket near Earth, its trajectory depends on various factors such as its initial velocity, position, and the gravitational forces it experiences. Depending on these initial conditions, the payload can follow different types of trajectories such as elliptical, parabolic, or hyperbolic. These trajectories are critical for space missions, including satellite deployment, payload recovery, and even interplanetary travel. Understanding the different trajectories that a payload can follow, based on its velocity and position relative to Earth, is essential for mission planning. This document discusses the underlying physics of gravitational forces, derives the equations of motion, explains the types of possible trajectories, and provides a simulation of a payload's trajectory near Earth.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_3/#gravitational-force-and-equations-of-motion","text":"The motion of a payload near Earth is governed by Newton\u2019s law of gravitation. The gravitational force acting on an object of mass \\(m\\) at a distance \\(r\\) from the center of Earth is given by: \\[ F = \\frac{GMm}{r^2} \\] Where: \\(F\\) is the gravitational force (in newtons), \\(G\\) is the gravitational constant, \\(6.67430 \\times 10^{-11}\\) m\u00b3/kg\u22c5s\u00b2, \\(M\\) is the mass of Earth ( \\(5.972 \\times 10^{24}\\) kg), \\(m\\) is the mass of the payload, \\(r\\) is the distance from the center of Earth to the payload (in meters). The force is responsible for the acceleration of the payload towards Earth. The acceleration \\(a\\) is given by: \\[ a = \\frac{F}{m} = \\frac{GM}{r^2} \\] This is also referred to as gravitational acceleration . The second-order differential equations describing the motion of an object under Earth's gravity are: \\[ \\frac{d^2 x}{dt^2} = -\\frac{GM x}{(x^2 + y^2)^{3/2}}, \\quad \\frac{d^2 y}{dt^2} = -\\frac{GM y}{(x^2 + y^2)^{3/2}} \\] These equations form the foundation for calculating the trajectory of the payload.","title":"Gravitational Force and Equations of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#additional-mathematical-computations","text":"Let's now expand on the motion using a specific example to compute the initial velocities and energy in different scenarios: Escape Velocity Computation The escape velocity at a given distance \\(r\\) from the center of Earth is given by: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] At Earth's surface, \\(r = R_{\\text{Earth}} = 6.371 \\times 10^6\\) m: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2 \\times 6.67430 \\times 10^{-11} \\times 5.972 \\times 10^{24}}{6.371 \\times 10^6}} \\approx 11200 \\, \\text{m/s} \\] Energy Conservation in Gravitational Motion For a payload, the total mechanical energy is conserved in the absence of other forces. The total energy \\(E\\) is the sum of the kinetic and potential energies: \\[ E = \\frac{1}{2} m v^2 - \\frac{GMm}{r} \\] Where: \\(v\\) is the velocity of the payload, \\(r\\) is the distance from the center of Earth. For different initial velocities, we compute the total energy: For a payload at \\(r = 2 \\times R_{\\text{Earth}}\\) with an initial velocity of \\(v_0 = 9000 \\, \\text{m/s}\\) : \\[ E = \\frac{1}{2} m (9000)^2 - \\frac{GMm}{2R_{\\text{Earth}}} \\] This can be expanded for different scenarios as part of a trajectory analysis.","title":"Additional Mathematical Computations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories","text":"The trajectory of a payload released near Earth depends on its initial velocity. Based on the velocity, the trajectory could be one of the following:","title":"Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-elliptical-trajectory","text":"When the initial velocity is less than the escape velocity, the payload follows an elliptical trajectory. The payload will eventually return to Earth after completing its elliptical orbit. This type of trajectory is typical for satellites in low Earth orbit (LEO). The general equation for an elliptical orbit is derived from Kepler's Laws: \\[ r(t) = \\frac{a(1 - e^2)}{1 + e \\cos(\\theta)} \\] Where: \\(a\\) is the semi-major axis, \\(e\\) is the orbital eccentricity, \\(\\theta\\) is the true anomaly (the angle between the payload and the periapsis).","title":"1. Elliptical Trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-parabolic-trajectory","text":"When the payload's initial velocity is equal to the escape velocity at a given distance from Earth, its trajectory will be parabolic. A parabolic trajectory is the boundary between bound and unbound motion, and it represents the exact condition for escaping Earth's gravity.","title":"2. Parabolic Trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-hyperbolic-trajectory","text":"If the payload's initial velocity exceeds the escape velocity, the trajectory will be hyperbolic. In this case, the payload escapes Earth's gravitational influence completely, traveling on a path that takes it far beyond Earth.","title":"3. Hyperbolic Trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation-of-trajectories","text":"To simulate the trajectory of a payload under the influence of Earth\u2019s gravity, we use numerical methods, particularly Runge-Kutta and adaptive solvers to solve the equations of motion. Below is an extended version of the code with multiple scenarios and further mathematical computations. Learn more here . import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # m\u00b3/kg/s\u00b2 M_earth = 5.972e24 # kg R_earth = 6.371e6 # m def equations(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M_earth * x / r**3 ay = -G * M_earth * y / r**3 return [vx, vy, ax, ay] def simulate_trajectory(y0, t_max, solver='RK45'): t_span = (0, t_max) t_eval = np.linspace(0, t_max, 2000) sol = solve_ivp(equations, t_span, y0, t_eval=t_eval, method=solver, rtol=1e-8) return sol # Different scenarios for simulation scenarios = { \"LEO (Circular Orbit)\": [R_earth + 300e3, 0, 0, 7800], # LEO example \"Suborbital\": [R_earth + 100e3, 0, 0, 5000], # Suborbital trajectory \"Escape Trajectory\": [R_earth + 300e3, 0, 0, 11200], # Escape velocity \"Hyperbolic Escape\": [R_earth + 300e3, 0, 0, 12000] # Hyperbolic trajectory } # Visualize the trajectories plt.figure(figsize=(12, 12)) for label, initial_conditions in scenarios.items(): sol = simulate_trajectory(initial_conditions, 5000) plt.plot(sol.y[0], sol.y[1], label=label) plt.scatter(0, 0, color='red', label='Earth Center') plt.xlabel(\"X Position (m)\") plt.ylabel(\"Y Position (m)\") plt.legend() plt.grid() plt.title(\"Different Trajectories of a Released Payload\") plt.show()","title":"Numerical Simulation of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#additional-example-calculation-of-energy","text":"To further illustrate the differences in energy at various positions, consider the following energy calculation for a payload with initial velocity \\(v_0 = 9000 \\, \\text{m/s}\\) at \\(r = 2 \\times R_{\\text{Earth}}\\) : Compute the total mechanical energy: \\[ E = \\frac{1}{2} m v_0^2 - \\frac{GMm}{r} \\] For \\(v_0 = 9000 \\, \\text{m/s}\\) and \\(r = 2R_{\\text{Earth}}\\) : \\[ E = \\frac{1}{2} m (9000)^2 - \\frac{G M m}{2R_{\\text{Earth}}} \\]","title":"Additional Example: Calculation of Energy"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"This study explored payload trajectories mathematically and computationally, deriving governing equations, implementing numerical solutions with improved accuracy, and providing multiple examples. These additional mathematical calculations, including energy considerations and velocity computations, provide further insight into how different initial conditions affect the trajectory.","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface Introduction Interference occurs when waves from multiple sources overlap and combine to produce new wave patterns. This phenomenon can be clearly observed on the surface of water, where ripples from different points meet and either amplify or cancel each other. In this problem, we will analyze the interference patterns resulting from the superposition of waves emitted by point sources placed at the vertices of a regular polygon. We will start by deriving the equation for the displacement at any point due to a single point source and then extend this to the case where multiple sources are used. We will visualize the interference patterns and analyze regions of constructive and destructive interference. Wave Equation for a Single Source The displacement of the water surface at a point \\( P(x, y) \\) due to a point source located at \\( S_i(x_i, y_i) \\) is given by the following wave equation: \\[ \\psi_i(x, y, t) = A \\sin(k r_i - \\omega t + \\phi) \\] Where: \\( A \\) is the amplitude of the wave, \\( k = \\frac{2\\pi}{\\lambda} \\) is the wave number, with \\( \\lambda \\) being the wavelength, \\( \\omega = 2\\pi f \\) is the angular frequency, with \\( f \\) being the frequency, \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) is the distance from the source \\( S_i(x_i, y_i) \\) to the point \\( P(x, y) \\) , \\( t \\) is time, \\( \\phi \\) is the initial phase of the wave. Superposition of Waves For multiple sources, the total displacement at any point on the water surface is given by the superposition of the displacements from each source: \\[ \\psi(x, y, t) = \\sum\\_{i=1}^{n} A \\sin(k r_i - \\omega t + \\phi) \\] Where \\( n \\) is the number of sources (vertices of the regular polygon). Problem Statement We are tasked with analyzing the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a regular polygon. For this example, we will use a regular pentagon with 5 vertices. Step 1: Positioning the Sources We place the point sources at the vertices of a regular pentagon inscribed in a circle with the center at the origin \\( (0, 0) \\) . The radius of the circle is \\( r\\_{\\text{source}} = 5 \\) meters. The angular positions of the vertices are given by the angles \\( \\theta_i = \\frac{2\\pi i}{n} \\) , where \\( i = 0, 1, 2, 3, 4 \\) and \\( n = 5 \\) for a pentagon. The coordinates of the sources are: Source \\( S_i \\) Coordinates \\( (x_i, y_i) \\) \\( S_1 \\) \\( (5, 0) \\) \\( S_2 \\) \\( \\left(-\\frac{5}{2}, \\frac{5\\sqrt{3}}{2}\\right) \\) \\( S_3 \\) \\( (-5, 0) \\) \\( S_4 \\) \\( \\left(-\\frac{5}{2}, -\\frac{5\\sqrt{3}}{2}\\right) \\) \\( S_5 \\) \\( (5, 0) \\) Step 2: Wave Equations for Each Source For each source \\( S_i \\) , the wave equation is of the form: \\[ \\psi_i(x, y, t) = A \\sin(k r_i - \\omega t + \\phi) \\] Where \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) is the distance from the source \\( S_i(x_i, y_i) \\) to the point \\( P(x, y) \\) . Step 3: Superposition of Waves The total displacement at any point on the water surface is the sum of the contributions from each of the 5 sources: \\[ \\psi(x, y, t) = \\sum\\_{i=1}^{5} A \\sin(k r_i - \\omega t + \\phi) \\] Step 4: Interference Pattern To analyze the interference pattern, we will calculate the displacement at various points on the water surface. Constructive interference occurs when the waves from different sources are in phase, and destructive interference occurs when the waves are out of phase. Step 5: Example Calculation Let\u2019s assume: \\( A = 1 \\) (amplitude), \\( \\lambda = 1 \\) m (wavelength), \\( f = 1 \\) Hz (frequency), \\( \\phi = 0 \\) (initial phase). The wave number \\( k \\) and angular frequency \\( \\omega \\) are: \\[ k = \\frac{2\\pi}{\\lambda} = 2\\pi, \\quad \\omega = 2\\pi f = 2\\pi \\] Now we will calculate the displacement at a point \\( P(1, 1) \\) . First, compute the distances from each of the five sources to the point \\( P \\) : Source \\( S_i \\) Coordinates \\( (x_i, y_i) \\) Distance \\( r_i \\) to \\( P(1, 1) \\) (m) \\( S_1 \\) \\( (5, 0) \\) \\( \\sqrt{(1 - 5)^2 + (1 - 0)^2} = \\sqrt{16 + 1} = \\sqrt{17} \\) \\( S_2 \\) \\( \\left(-\\frac{5}{2}, \\frac{5\\sqrt{3}}{2}\\right) \\) \\( \\sqrt{(1 + \\frac{5}{2})^2 + (1 - \\frac{5\\sqrt{3}}{2})^2} \\) \\( S_3 \\) \\( (-5, 0) \\) \\( \\sqrt{(1 + 5)^2 + (1 - 0)^2} = \\sqrt{36 + 1} = \\sqrt{37} \\) \\( S_4 \\) \\( \\left(-\\frac{5}{2}, -\\frac{5\\sqrt{3}}{2}\\right) \\) \\( \\sqrt{(1 + \\frac{5}{2})^2 + (1 + \\frac{5\\sqrt{3}}{2})^2} \\) \\( S_5 \\) \\( (5, 0) \\) \\( \\sqrt{(1 - 5)^2 + (1 - 0)^2} = \\sqrt{16 + 1} = \\sqrt{17} \\) Once the distances \\( r_i \\) are computed, we substitute them into the wave equation for each source and sum the contributions to find the total displacement at the point \\( P(1, 1) \\) . Visualization of the Interference Pattern We now use Python\u2019s matplotlib to plot the interference patterns for various points on the surface. Plot 1: Interference Pattern on a Grid import numpy as np import matplotlib.pyplot as plt # Constants A = 1 lambda_ = 1 f = 1 omega = 2 * np.pi * f k = 2 * np.pi / lambda_ phi = 0 n_sources = 5 # Positions of the sources (vertices of a regular pentagon) r_source = 5 theta = np.linspace(0, 2 * np.pi, n_sources, endpoint=False) sources = np.array([r_source * np.cos(theta), r_source * np.sin(theta)]).T # Create a grid of points on the water surface x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Calculate the displacement at each point on the grid total_displacement = np.zeros(X.shape) for (x_s, y_s) in sources: r = np.sqrt((X - x_s)**2 + (Y - y_s)**2) displacement = A * np.sin(k * r - omega * 0 + phi) total_displacement += displacement # Plot the interference pattern plt.figure(figsize=(12, 7.5)) plt.contourf(X, Y, total_displacement, 20, cmap='RdBu') plt.colorbar(label=\"Displacement\") plt.scatter(sources[:, 0], sources[:, 1], color='black', label='Sources', marker='x') plt.title(\"Interference Pattern from Point Sources on a Water Surface\") plt.xlabel(\"x (meters)\") plt.ylabel(\"y (meters)\") plt.legend() plt.axis('equal') plt.show() Plot 2: Cross-Section of the Interference Pattern # Take a cross-section along the x-axis (y = 0) y_cross_section = 0 displacement_cross_section = np.sum([A * np.sin(k * np.sqrt((x - x_s)**2 + (y_cross_section - y_s)**2) - omega * 0 + phi) for (x_s, y_s) in sources], axis=0) # Plot the cross-section plt.figure(figsize=(12, 7.5)) plt.plot(x, displacement_cross_section) plt.title(\"Cross-Section of the Interference Pattern (y = 0)\") plt.xlabel(\"x (meters)\") plt.ylabel(\"Displacement\") plt.grid(True) plt.show() Interference Pattern Description Constructive Interference : Bright regions in the contour plot indicate constructive interference, where the waves from multiple sources combine in phase, resulting in a large displacement. Destructive Interference : Dark regions indicate destructive interference, where the waves from multiple sources cancel each other out, resulting in a small displacement. Conclusion The interference patterns formed by the superposition of waves from point sources placed at the vertices of a regular polygon (in this case, a pentagon) exhibit regions of constructive and destructive interference. The symmetry of the polygon leads to regular patterns of amplification and cancellation of the wave amplitudes. These patterns can be visualized using graphical tools like Python\u2019s matplotlib , and the results highlight the fascinating nature of wave interactions. By adjusting parameters such as frequency, amplitude, and the number of sources, we can further explore the complex behaviors of waves in two-dimensional spaces.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#introduction","text":"Interference occurs when waves from multiple sources overlap and combine to produce new wave patterns. This phenomenon can be clearly observed on the surface of water, where ripples from different points meet and either amplify or cancel each other. In this problem, we will analyze the interference patterns resulting from the superposition of waves emitted by point sources placed at the vertices of a regular polygon. We will start by deriving the equation for the displacement at any point due to a single point source and then extend this to the case where multiple sources are used. We will visualize the interference patterns and analyze regions of constructive and destructive interference.","title":"Introduction"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-equation-for-a-single-source","text":"The displacement of the water surface at a point \\( P(x, y) \\) due to a point source located at \\( S_i(x_i, y_i) \\) is given by the following wave equation: \\[ \\psi_i(x, y, t) = A \\sin(k r_i - \\omega t + \\phi) \\] Where: \\( A \\) is the amplitude of the wave, \\( k = \\frac{2\\pi}{\\lambda} \\) is the wave number, with \\( \\lambda \\) being the wavelength, \\( \\omega = 2\\pi f \\) is the angular frequency, with \\( f \\) being the frequency, \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) is the distance from the source \\( S_i(x_i, y_i) \\) to the point \\( P(x, y) \\) , \\( t \\) is time, \\( \\phi \\) is the initial phase of the wave.","title":"Wave Equation for a Single Source"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-of-waves","text":"For multiple sources, the total displacement at any point on the water surface is given by the superposition of the displacements from each source: \\[ \\psi(x, y, t) = \\sum\\_{i=1}^{n} A \\sin(k r_i - \\omega t + \\phi) \\] Where \\( n \\) is the number of sources (vertices of the regular polygon).","title":"Superposition of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-statement","text":"We are tasked with analyzing the interference patterns formed on the water surface due to the superposition of waves emitted from point sources placed at the vertices of a regular polygon. For this example, we will use a regular pentagon with 5 vertices.","title":"Problem Statement"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-1-positioning-the-sources","text":"We place the point sources at the vertices of a regular pentagon inscribed in a circle with the center at the origin \\( (0, 0) \\) . The radius of the circle is \\( r\\_{\\text{source}} = 5 \\) meters. The angular positions of the vertices are given by the angles \\( \\theta_i = \\frac{2\\pi i}{n} \\) , where \\( i = 0, 1, 2, 3, 4 \\) and \\( n = 5 \\) for a pentagon. The coordinates of the sources are: Source \\( S_i \\) Coordinates \\( (x_i, y_i) \\) \\( S_1 \\) \\( (5, 0) \\) \\( S_2 \\) \\( \\left(-\\frac{5}{2}, \\frac{5\\sqrt{3}}{2}\\right) \\) \\( S_3 \\) \\( (-5, 0) \\) \\( S_4 \\) \\( \\left(-\\frac{5}{2}, -\\frac{5\\sqrt{3}}{2}\\right) \\) \\( S_5 \\) \\( (5, 0) \\)","title":"Step 1: Positioning the Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-2-wave-equations-for-each-source","text":"For each source \\( S_i \\) , the wave equation is of the form: \\[ \\psi_i(x, y, t) = A \\sin(k r_i - \\omega t + \\phi) \\] Where \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) is the distance from the source \\( S_i(x_i, y_i) \\) to the point \\( P(x, y) \\) .","title":"Step 2: Wave Equations for Each Source"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-3-superposition-of-waves","text":"The total displacement at any point on the water surface is the sum of the contributions from each of the 5 sources: \\[ \\psi(x, y, t) = \\sum\\_{i=1}^{5} A \\sin(k r_i - \\omega t + \\phi) \\]","title":"Step 3: Superposition of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-4-interference-pattern","text":"To analyze the interference pattern, we will calculate the displacement at various points on the water surface. Constructive interference occurs when the waves from different sources are in phase, and destructive interference occurs when the waves are out of phase.","title":"Step 4: Interference Pattern"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-5-example-calculation","text":"Let\u2019s assume: \\( A = 1 \\) (amplitude), \\( \\lambda = 1 \\) m (wavelength), \\( f = 1 \\) Hz (frequency), \\( \\phi = 0 \\) (initial phase). The wave number \\( k \\) and angular frequency \\( \\omega \\) are: \\[ k = \\frac{2\\pi}{\\lambda} = 2\\pi, \\quad \\omega = 2\\pi f = 2\\pi \\] Now we will calculate the displacement at a point \\( P(1, 1) \\) . First, compute the distances from each of the five sources to the point \\( P \\) : Source \\( S_i \\) Coordinates \\( (x_i, y_i) \\) Distance \\( r_i \\) to \\( P(1, 1) \\) (m) \\( S_1 \\) \\( (5, 0) \\) \\( \\sqrt{(1 - 5)^2 + (1 - 0)^2} = \\sqrt{16 + 1} = \\sqrt{17} \\) \\( S_2 \\) \\( \\left(-\\frac{5}{2}, \\frac{5\\sqrt{3}}{2}\\right) \\) \\( \\sqrt{(1 + \\frac{5}{2})^2 + (1 - \\frac{5\\sqrt{3}}{2})^2} \\) \\( S_3 \\) \\( (-5, 0) \\) \\( \\sqrt{(1 + 5)^2 + (1 - 0)^2} = \\sqrt{36 + 1} = \\sqrt{37} \\) \\( S_4 \\) \\( \\left(-\\frac{5}{2}, -\\frac{5\\sqrt{3}}{2}\\right) \\) \\( \\sqrt{(1 + \\frac{5}{2})^2 + (1 + \\frac{5\\sqrt{3}}{2})^2} \\) \\( S_5 \\) \\( (5, 0) \\) \\( \\sqrt{(1 - 5)^2 + (1 - 0)^2} = \\sqrt{16 + 1} = \\sqrt{17} \\) Once the distances \\( r_i \\) are computed, we substitute them into the wave equation for each source and sum the contributions to find the total displacement at the point \\( P(1, 1) \\) .","title":"Step 5: Example Calculation"},{"location":"1%20Physics/3%20Waves/Problem_1/#visualization-of-the-interference-pattern","text":"We now use Python\u2019s matplotlib to plot the interference patterns for various points on the surface.","title":"Visualization of the Interference Pattern"},{"location":"1%20Physics/3%20Waves/Problem_1/#plot-1-interference-pattern-on-a-grid","text":"import numpy as np import matplotlib.pyplot as plt # Constants A = 1 lambda_ = 1 f = 1 omega = 2 * np.pi * f k = 2 * np.pi / lambda_ phi = 0 n_sources = 5 # Positions of the sources (vertices of a regular pentagon) r_source = 5 theta = np.linspace(0, 2 * np.pi, n_sources, endpoint=False) sources = np.array([r_source * np.cos(theta), r_source * np.sin(theta)]).T # Create a grid of points on the water surface x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Calculate the displacement at each point on the grid total_displacement = np.zeros(X.shape) for (x_s, y_s) in sources: r = np.sqrt((X - x_s)**2 + (Y - y_s)**2) displacement = A * np.sin(k * r - omega * 0 + phi) total_displacement += displacement # Plot the interference pattern plt.figure(figsize=(12, 7.5)) plt.contourf(X, Y, total_displacement, 20, cmap='RdBu') plt.colorbar(label=\"Displacement\") plt.scatter(sources[:, 0], sources[:, 1], color='black', label='Sources', marker='x') plt.title(\"Interference Pattern from Point Sources on a Water Surface\") plt.xlabel(\"x (meters)\") plt.ylabel(\"y (meters)\") plt.legend() plt.axis('equal') plt.show()","title":"Plot 1: Interference Pattern on a Grid"},{"location":"1%20Physics/3%20Waves/Problem_1/#plot-2-cross-section-of-the-interference-pattern","text":"# Take a cross-section along the x-axis (y = 0) y_cross_section = 0 displacement_cross_section = np.sum([A * np.sin(k * np.sqrt((x - x_s)**2 + (y_cross_section - y_s)**2) - omega * 0 + phi) for (x_s, y_s) in sources], axis=0) # Plot the cross-section plt.figure(figsize=(12, 7.5)) plt.plot(x, displacement_cross_section) plt.title(\"Cross-Section of the Interference Pattern (y = 0)\") plt.xlabel(\"x (meters)\") plt.ylabel(\"Displacement\") plt.grid(True) plt.show()","title":"Plot 2: Cross-Section of the Interference Pattern"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-pattern-description","text":"Constructive Interference : Bright regions in the contour plot indicate constructive interference, where the waves from multiple sources combine in phase, resulting in a large displacement. Destructive Interference : Dark regions indicate destructive interference, where the waves from multiple sources cancel each other out, resulting in a small displacement.","title":"Interference Pattern Description"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"The interference patterns formed by the superposition of waves from point sources placed at the vertices of a regular polygon (in this case, a pentagon) exhibit regions of constructive and destructive interference. The symmetry of the polygon leads to regular patterns of amplification and cancellation of the wave amplitudes. These patterns can be visualized using graphical tools like Python\u2019s matplotlib , and the results highlight the fascinating nature of wave interactions. By adjusting parameters such as frequency, amplitude, and the number of sources, we can further explore the complex behaviors of waves in two-dimensional spaces.","title":"Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"}]}