{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Projectile Motion Analysis and Simulation Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation Projectile motion is a fundamental topic in classical mechanics, describing the motion of an object launched into the air under the influence of gravity. It plays a crucial role in various real-world applications, such as ballistics, sports, and space exploration. Understanding projectile motion requires analyzing both horizontal and vertical components independently, assuming no external forces except gravity (neglecting air resistance initially). By exploring its equations, derivations, and computational approaches, we can gain deeper insights into the factors influencing projectile trajectory. 1.1 Equations of Motion The motion of a projectile launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) is governed by the fundamental kinematic equations. 1.1.1 Horizontal Motion Since there is no horizontal acceleration (neglecting air resistance), the horizontal displacement is given by: \\[ x = v_0 \\cos(\\theta) t \\] where: \\( x \\) = horizontal displacement \\( v_0 \\) = initial velocity \\( \\theta \\) = launch angle \\( t \\) = time 1.1.2 Vertical Motion The vertical motion is influenced by gravity \\( g \\) , leading to the equation: \\[ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] where: \\( y \\) = vertical displacement \\( g \\) = acceleration due to gravity (9.81 m/s\u00b2) 1.2 Derivation of Key Equations 1.2.1 Time of Flight The total time of flight occurs when the projectile returns to the ground (i.e., \\( y = 0 \\) ). Setting the vertical displacement equation to zero: \\[ 0 = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] Factoring out \\( t \\) : \\[ t (v_0 \\sin(\\theta) - \\frac{1}{2} g t) = 0 \\] Solving for \\( t \\) : \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] 1.2.2 Range of the Projectile The range \\( R \\) is the horizontal distance traveled before the projectile lands: \\[ R = v_0 \\cos(\\theta) t_f \\] Substituting \\( t_f \\) from above: \\[ R = v_0 \\cos(\\theta) \\times \\frac{2 v_0 \\sin(\\theta)}{g} \\] Using the trigonometric identity \\( 2 \\sin(\\theta) \\cos(\\theta) = \\sin(2\\theta) \\) , we get: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] 1.2.3 Maximum Height At the peak, the vertical velocity is zero \\( (v_y = 0) \\) . Using the kinematic equation: \\[ v_y^2 = v_0^2 \\sin^2(\\theta) - 2 g H \\] Setting \\( v_y = 0 \\) : \\[ 0 = v_0^2 \\sin^2(\\theta) - 2 g H \\] Solving for \\( H \\) : \\[ H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\] 1.3 Effects of Air Resistance Without air resistance, projectiles follow a parabolic trajectory . However, with air resistance, the motion becomes more complex due to a drag force \\( F_d \\) , given by: \\[ F_d = \\frac{1}{2} C_d \\rho A v^2 \\] where: \\( C_d \\) = drag coefficient (depends on object shape) \\( \\rho \\) = air density (kg/m\u00b3) \\( A \\) = cross-sectional area (m\u00b2) \\( v \\) = velocity (m/s) 1.4 Numerical Computation with Air Resistance With air resistance, the equations of motion become nonlinear differential equations: 1.4.1 Horizontal Motion with Drag \\[ m \\frac{dv_x}{dt} = -\\frac{1}{2} C_d \\rho A v v_x \\] 1.4.2 Vertical Motion with Drag \\[ m \\frac{dv_y}{dt} = -mg - \\frac{1}{2} C_d \\rho A v v_y \\] where \\( v_x \\) and \\( v_y \\) are the horizontal and vertical velocity components. These equations require numerical methods (such as Euler\u2019s method or Runge-Kutta) for solving. 1.5 Summary of Important Equations Quantity Equation Horizontal Position \\( x = v_0 \\cos(\\theta) t \\) Vertical Position \\( y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\) Time of Flight \\( t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\) Range \\( R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\) Maximum Height \\( H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\) Drag Force \\( F_d = \\frac{1}{2} C_d \\rho A v^2 \\) 2. Analytical Analysis of Range import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # gravitational acceleration (m/s\u00b2) v0 = 10 # initial velocity (m/s) # Angle range (0\u00b0 to 90\u00b0) theta = np.linspace(0, 90, 100) theta_rad = np.radians(theta) # Convert to radians # Compute range R = (v0**2 * np.sin(2 * theta_rad)) / g # Plot range vs. angle plt.figure(figsize=(12, 7.5)) plt.plot(theta, R, label=f'Initial velocity = {v0} m/s') plt.xlabel('Launch Angle (\u00b0)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show() This section plots range vs. launch angle without air resistance. Learn more. 3. Numerical Simulation with Air Resistance import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # Gravity (m/s\u00b2) rho = 1.225 # Air density (kg/m\u00b3) Cd = 0.47 # Drag coefficient (sphere) A = 0.01 # Cross-sectional area (m\u00b2) m = 0.145 # Mass of projectile (kg) (e.g., baseball) def equations(t, state, Cd, A, m, rho): \"\"\"Differential equations for projectile motion with air resistance.\"\"\" x, y, vx, vy = state v = np.sqrt(vx**2 + vy**2) # Speed drag = (0.5 * Cd * rho * A * v**2) / m # Drag acceleration ax = -drag * (vx / v) # Drag in x-direction ay = -g - drag * (vy / v) # Drag in y-direction return [vx, vy, ax, ay] def solve_projectile(v0, theta_deg, Cd=0.47): \"\"\"Solve projectile motion with air resistance using numerical integration.\"\"\" theta = np.radians(theta_deg) vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) # Initial conditions state0 = [0, 0, vx0, vy0] # Solve using solve_ivp t_span = (0, 5) # Time range t_eval = np.linspace(0, 5, 300) # Time points for solution sol = solve_ivp(equations, t_span, state0, t_eval=t_eval, args=(Cd, A, m, rho)) return sol.t, sol.y[0], sol.y[1] # Time, x, y def plot_trajectory(arr_args): \"\"\"Plots projectile motion with adjustable parameters.\"\"\" plt.figure(figsize=(12, 7.5)) for item in arr_args: v0, theta_deg, Cd = item t, x, y = solve_projectile(v0, theta_deg, Cd) plt.plot(x, y, label=f'v0={v0} m/s, \u03b8={theta_deg}\u00b0, Cd={Cd}') plt.xlabel('Distance (m)') plt.ylabel('Height (m)') plt.title('Projectile Motion with Air Resistance') plt.legend() plt.grid() plt.ylim(0) # Ensure ground level is visible plt.show() # Example Plot plot_trajectory([(40, 45, 0.47), (40, 45, 0.2), (40, 45, 0.1), (40, 40, 0.47), (40, 30, 0.47), (40, 20, 0.47), (30, 40, 0.47), (20, 40, 0.47), (15, 40, 0.47)]) Here, we use ODE solvers to simulate projectile motion with drag. Learn more. 4. Interactive Simulation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp import ipywidgets as widgets from IPython.display import display # Constants g = 9.81 # Gravity (m/s\u00b2) rho = 1.225 # Air density (kg/m\u00b3) A = 0.01 # Cross-sectional area (m\u00b2) m = 0.145 # Mass of projectile (kg) (e.g., baseball) # Define equations of motion def equations(t, state, Cd, A, m, rho): x, y, vx, vy = state v = np.sqrt(vx**2 + vy**2) # Speed magnitude drag = (0.5 * Cd * rho * A * v**2) / m # Drag force ax = -drag * (vx / v) # Acceleration in x ay = -g - drag * (vy / v) # Acceleration in y return [vx, vy, ax, ay] # Solve equations using Runge-Kutta def solve_projectile(v0, theta_deg, Cd): theta = np.radians(theta_deg) vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) state0 = [0, 0, vx0, vy0] t_span = (0, 5) t_eval = np.linspace(0, 5, 300) sol = solve_ivp(equations, t_span, state0, t_eval=t_eval, args=(Cd, A, m, rho)) return sol.y[0], sol.y[1] # Return x and y coordinates # Function to update plot dynamically def update_plot(v0, theta_deg, Cd): fig, ax = plt.subplots(figsize=(12, 7.5)) # Create new figure each time ax.set_xlabel('Distance (m)') ax.set_ylabel('Height (m)') ax.set_title('Projectile Motion with Air Resistance') ax.set_xlim(0, 50) # Set fixed axis limits ax.set_ylim(0, 15) ax.grid() x, y = solve_projectile(v0, theta_deg, Cd) # Solve motion equations ax.plot(x, y, label=f'v0={v0} m/s, \u03b8={theta_deg}\u00b0, Cd={Cd}', color='b') ax.legend() plt.show() # Display updated plot # Interactive widgets v0_slider = widgets.FloatSlider(value=20, min=5, max=50, step=1, description='v0 (m/s)') theta_slider = widgets.FloatSlider(value=45, min=0, max=90, step=1, description='Angle (\u00b0)') Cd_slider = widgets.FloatSlider(value=0.47, min=0, max=1.5, step=0.05, description='Cd (Drag)') # Link widgets with update function out = widgets.interactive_output(update_plot, {'v0': v0_slider, 'theta_deg': theta_slider, 'Cd': Cd_slider}) # Display the widgets and plot ui = widgets.VBox([v0_slider, theta_slider, Cd_slider]) display(ui, out) This section adds sliders for interactive tuning of launch parameters. Learn more. 5. Launch from Different Heights import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # Gravity (m/s\u00b2) rho = 1.225 # Air density (kg/m\u00b3) Cd = 0.47 # Drag coefficient (sphere) A = 0.01 # Cross-sectional area (m\u00b2) m = 0.145 # Mass of projectile (kg) (e.g., baseball) def equations(t, state, Cd, A, m, rho): \"\"\"Differential equations for projectile motion with air resistance.\"\"\" x, y, vx, vy = state v = np.sqrt(vx**2 + vy**2) # Speed drag = (0.5 * Cd * rho * A * v**2) / m # Drag acceleration ax = -drag * (vx / v) # Drag in x-direction ay = -g - drag * (vy / v) # Drag in y-direction return [vx, vy, ax, ay] def solve_projectile_height(v0, theta_deg, y0, Cd=0.47): \"\"\"Solve projectile motion with different initial heights.\"\"\" theta = np.radians(theta_deg) vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) # Initial conditions state0 = [0, y0, vx0, vy0] # Solve sol = solve_ivp(equations, (0, 10), state0, t_eval=np.linspace(0, 10, 500), args=(Cd, A, m, rho)) return sol.t, sol.y[0], sol.y[1] # Example Plot def plot_trajectory(para_list): plt.figure(figsize=(12, 7.5)) for para in para_list: v0, theta_deg, Cd, init_height = para t, x, y = solve_projectile_height(v0, theta_deg, init_height, Cd) plt.plot(x, y, label=f'v0={v0} m/s, \u03b8={theta_deg}\u00b0, Cd={Cd}, y0={init_height}m') plt.xlabel('Distance (m)') plt.ylabel('Height (m)') plt.title('Projectile Motion with Air Resistance') plt.legend() plt.grid() plt.ylim(0) plt.show() # Example: Launch from different height plot_trajectory([(20, 45, 0.47, 3), (20, 45, 0.47, 6), (20, 45, 0.47, 9), (20, 45, 0.47, 12)]) We modify our simulation to allow for launch at y\u2080\u22600. This affects the time of flight calculation. Learn more.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-analysis-and-simulation","text":"","title":"Projectile Motion Analysis and Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion is a fundamental topic in classical mechanics, describing the motion of an object launched into the air under the influence of gravity. It plays a crucial role in various real-world applications, such as ballistics, sports, and space exploration. Understanding projectile motion requires analyzing both horizontal and vertical components independently, assuming no external forces except gravity (neglecting air resistance initially). By exploring its equations, derivations, and computational approaches, we can gain deeper insights into the factors influencing projectile trajectory.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-equations-of-motion","text":"The motion of a projectile launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) is governed by the fundamental kinematic equations.","title":"1.1 Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#111-horizontal-motion","text":"Since there is no horizontal acceleration (neglecting air resistance), the horizontal displacement is given by: \\[ x = v_0 \\cos(\\theta) t \\] where: \\( x \\) = horizontal displacement \\( v_0 \\) = initial velocity \\( \\theta \\) = launch angle \\( t \\) = time","title":"1.1.1 Horizontal Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#112-vertical-motion","text":"The vertical motion is influenced by gravity \\( g \\) , leading to the equation: \\[ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] where: \\( y \\) = vertical displacement \\( g \\) = acceleration due to gravity (9.81 m/s\u00b2)","title":"1.1.2 Vertical Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-derivation-of-key-equations","text":"","title":"1.2 Derivation of Key Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#121-time-of-flight","text":"The total time of flight occurs when the projectile returns to the ground (i.e., \\( y = 0 \\) ). Setting the vertical displacement equation to zero: \\[ 0 = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\] Factoring out \\( t \\) : \\[ t (v_0 \\sin(\\theta) - \\frac{1}{2} g t) = 0 \\] Solving for \\( t \\) : \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\]","title":"1.2.1 Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#122-range-of-the-projectile","text":"The range \\( R \\) is the horizontal distance traveled before the projectile lands: \\[ R = v_0 \\cos(\\theta) t_f \\] Substituting \\( t_f \\) from above: \\[ R = v_0 \\cos(\\theta) \\times \\frac{2 v_0 \\sin(\\theta)}{g} \\] Using the trigonometric identity \\( 2 \\sin(\\theta) \\cos(\\theta) = \\sin(2\\theta) \\) , we get: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"1.2.2 Range of the Projectile"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#123-maximum-height","text":"At the peak, the vertical velocity is zero \\( (v_y = 0) \\) . Using the kinematic equation: \\[ v_y^2 = v_0^2 \\sin^2(\\theta) - 2 g H \\] Setting \\( v_y = 0 \\) : \\[ 0 = v_0^2 \\sin^2(\\theta) - 2 g H \\] Solving for \\( H \\) : \\[ H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\]","title":"1.2.3 Maximum Height"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-effects-of-air-resistance","text":"Without air resistance, projectiles follow a parabolic trajectory . However, with air resistance, the motion becomes more complex due to a drag force \\( F_d \\) , given by: \\[ F_d = \\frac{1}{2} C_d \\rho A v^2 \\] where: \\( C_d \\) = drag coefficient (depends on object shape) \\( \\rho \\) = air density (kg/m\u00b3) \\( A \\) = cross-sectional area (m\u00b2) \\( v \\) = velocity (m/s)","title":"1.3 Effects of Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#14-numerical-computation-with-air-resistance","text":"With air resistance, the equations of motion become nonlinear differential equations:","title":"1.4 Numerical Computation with Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#141-horizontal-motion-with-drag","text":"\\[ m \\frac{dv_x}{dt} = -\\frac{1}{2} C_d \\rho A v v_x \\]","title":"1.4.1 Horizontal Motion with Drag"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#142-vertical-motion-with-drag","text":"\\[ m \\frac{dv_y}{dt} = -mg - \\frac{1}{2} C_d \\rho A v v_y \\] where \\( v_x \\) and \\( v_y \\) are the horizontal and vertical velocity components. These equations require numerical methods (such as Euler\u2019s method or Runge-Kutta) for solving.","title":"1.4.2 Vertical Motion with Drag"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#15-summary-of-important-equations","text":"Quantity Equation Horizontal Position \\( x = v_0 \\cos(\\theta) t \\) Vertical Position \\( y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 \\) Time of Flight \\( t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\) Range \\( R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\) Maximum Height \\( H = \\frac{v_0^2 \\sin^2(\\theta)}{2g} \\) Drag Force \\( F_d = \\frac{1}{2} C_d \\rho A v^2 \\)","title":"1.5 Summary of Important Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analytical-analysis-of-range","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # gravitational acceleration (m/s\u00b2) v0 = 10 # initial velocity (m/s) # Angle range (0\u00b0 to 90\u00b0) theta = np.linspace(0, 90, 100) theta_rad = np.radians(theta) # Convert to radians # Compute range R = (v0**2 * np.sin(2 * theta_rad)) / g # Plot range vs. angle plt.figure(figsize=(12, 7.5)) plt.plot(theta, R, label=f'Initial velocity = {v0} m/s') plt.xlabel('Launch Angle (\u00b0)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Launch Angle') plt.legend() plt.grid() plt.show() This section plots range vs. launch angle without air resistance. Learn more.","title":"2. Analytical Analysis of Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-numerical-simulation-with-air-resistance","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # Gravity (m/s\u00b2) rho = 1.225 # Air density (kg/m\u00b3) Cd = 0.47 # Drag coefficient (sphere) A = 0.01 # Cross-sectional area (m\u00b2) m = 0.145 # Mass of projectile (kg) (e.g., baseball) def equations(t, state, Cd, A, m, rho): \"\"\"Differential equations for projectile motion with air resistance.\"\"\" x, y, vx, vy = state v = np.sqrt(vx**2 + vy**2) # Speed drag = (0.5 * Cd * rho * A * v**2) / m # Drag acceleration ax = -drag * (vx / v) # Drag in x-direction ay = -g - drag * (vy / v) # Drag in y-direction return [vx, vy, ax, ay] def solve_projectile(v0, theta_deg, Cd=0.47): \"\"\"Solve projectile motion with air resistance using numerical integration.\"\"\" theta = np.radians(theta_deg) vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) # Initial conditions state0 = [0, 0, vx0, vy0] # Solve using solve_ivp t_span = (0, 5) # Time range t_eval = np.linspace(0, 5, 300) # Time points for solution sol = solve_ivp(equations, t_span, state0, t_eval=t_eval, args=(Cd, A, m, rho)) return sol.t, sol.y[0], sol.y[1] # Time, x, y def plot_trajectory(arr_args): \"\"\"Plots projectile motion with adjustable parameters.\"\"\" plt.figure(figsize=(12, 7.5)) for item in arr_args: v0, theta_deg, Cd = item t, x, y = solve_projectile(v0, theta_deg, Cd) plt.plot(x, y, label=f'v0={v0} m/s, \u03b8={theta_deg}\u00b0, Cd={Cd}') plt.xlabel('Distance (m)') plt.ylabel('Height (m)') plt.title('Projectile Motion with Air Resistance') plt.legend() plt.grid() plt.ylim(0) # Ensure ground level is visible plt.show() # Example Plot plot_trajectory([(40, 45, 0.47), (40, 45, 0.2), (40, 45, 0.1), (40, 40, 0.47), (40, 30, 0.47), (40, 20, 0.47), (30, 40, 0.47), (20, 40, 0.47), (15, 40, 0.47)]) Here, we use ODE solvers to simulate projectile motion with drag. Learn more.","title":"3. Numerical Simulation with Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-interactive-simulation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp import ipywidgets as widgets from IPython.display import display # Constants g = 9.81 # Gravity (m/s\u00b2) rho = 1.225 # Air density (kg/m\u00b3) A = 0.01 # Cross-sectional area (m\u00b2) m = 0.145 # Mass of projectile (kg) (e.g., baseball) # Define equations of motion def equations(t, state, Cd, A, m, rho): x, y, vx, vy = state v = np.sqrt(vx**2 + vy**2) # Speed magnitude drag = (0.5 * Cd * rho * A * v**2) / m # Drag force ax = -drag * (vx / v) # Acceleration in x ay = -g - drag * (vy / v) # Acceleration in y return [vx, vy, ax, ay] # Solve equations using Runge-Kutta def solve_projectile(v0, theta_deg, Cd): theta = np.radians(theta_deg) vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) state0 = [0, 0, vx0, vy0] t_span = (0, 5) t_eval = np.linspace(0, 5, 300) sol = solve_ivp(equations, t_span, state0, t_eval=t_eval, args=(Cd, A, m, rho)) return sol.y[0], sol.y[1] # Return x and y coordinates # Function to update plot dynamically def update_plot(v0, theta_deg, Cd): fig, ax = plt.subplots(figsize=(12, 7.5)) # Create new figure each time ax.set_xlabel('Distance (m)') ax.set_ylabel('Height (m)') ax.set_title('Projectile Motion with Air Resistance') ax.set_xlim(0, 50) # Set fixed axis limits ax.set_ylim(0, 15) ax.grid() x, y = solve_projectile(v0, theta_deg, Cd) # Solve motion equations ax.plot(x, y, label=f'v0={v0} m/s, \u03b8={theta_deg}\u00b0, Cd={Cd}', color='b') ax.legend() plt.show() # Display updated plot # Interactive widgets v0_slider = widgets.FloatSlider(value=20, min=5, max=50, step=1, description='v0 (m/s)') theta_slider = widgets.FloatSlider(value=45, min=0, max=90, step=1, description='Angle (\u00b0)') Cd_slider = widgets.FloatSlider(value=0.47, min=0, max=1.5, step=0.05, description='Cd (Drag)') # Link widgets with update function out = widgets.interactive_output(update_plot, {'v0': v0_slider, 'theta_deg': theta_slider, 'Cd': Cd_slider}) # Display the widgets and plot ui = widgets.VBox([v0_slider, theta_slider, Cd_slider]) display(ui, out) This section adds sliders for interactive tuning of launch parameters. Learn more.","title":"4. Interactive Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-launch-from-different-heights","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # Gravity (m/s\u00b2) rho = 1.225 # Air density (kg/m\u00b3) Cd = 0.47 # Drag coefficient (sphere) A = 0.01 # Cross-sectional area (m\u00b2) m = 0.145 # Mass of projectile (kg) (e.g., baseball) def equations(t, state, Cd, A, m, rho): \"\"\"Differential equations for projectile motion with air resistance.\"\"\" x, y, vx, vy = state v = np.sqrt(vx**2 + vy**2) # Speed drag = (0.5 * Cd * rho * A * v**2) / m # Drag acceleration ax = -drag * (vx / v) # Drag in x-direction ay = -g - drag * (vy / v) # Drag in y-direction return [vx, vy, ax, ay] def solve_projectile_height(v0, theta_deg, y0, Cd=0.47): \"\"\"Solve projectile motion with different initial heights.\"\"\" theta = np.radians(theta_deg) vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) # Initial conditions state0 = [0, y0, vx0, vy0] # Solve sol = solve_ivp(equations, (0, 10), state0, t_eval=np.linspace(0, 10, 500), args=(Cd, A, m, rho)) return sol.t, sol.y[0], sol.y[1] # Example Plot def plot_trajectory(para_list): plt.figure(figsize=(12, 7.5)) for para in para_list: v0, theta_deg, Cd, init_height = para t, x, y = solve_projectile_height(v0, theta_deg, init_height, Cd) plt.plot(x, y, label=f'v0={v0} m/s, \u03b8={theta_deg}\u00b0, Cd={Cd}, y0={init_height}m') plt.xlabel('Distance (m)') plt.ylabel('Height (m)') plt.title('Projectile Motion with Air Resistance') plt.legend() plt.grid() plt.ylim(0) plt.show() # Example: Launch from different height plot_trajectory([(20, 45, 0.47, 3), (20, 45, 0.47, 6), (20, 45, 0.47, 9), (20, 45, 0.47, 12)]) We modify our simulation to allow for launch at y\u2080\u22600. This affects the time of flight calculation. Learn more.","title":"5. Launch from Different Heights"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a fascinating example of a system where damping, restoring forces, and external periodic forcing interplay to create rich dynamic behavior. This system exhibits a variety of phenomena, including resonance, chaos, and quasiperiodicity, making it a valuable subject for studying complex real-world systems such as driven oscillators, climate models, and mechanical structures under periodic stress. By adjusting parameters like damping, external force amplitude, and driving frequency, the system transitions through different behaviors, such as synchronized oscillations, chaotic motion, and resonance phenomena. Understanding these behaviors has significant implications for fields like energy harvesting, vibration isolation, and mechanical resonance. Theoretical Foundation The motion of a forced damped pendulum is governed by the differential equation: \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t)\\] where: \\( \\theta(t) \\) is the angular displacement, \\( b \\) is the damping coefficient, \\( g \\) is the gravitational acceleration, \\( L \\) is the length of the pendulum, \\( A \\) is the amplitude of the external force, \\( \\omega \\) is the driving frequency. Small-Angle Approximation For small angles, we approximate \\( \\sin\\theta \\approx \\theta \\) , reducing the equation to: \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t)\\] This equation describes a forced damped harmonic oscillator with the general solution: \\[\\theta(t) = \\theta_0 e^{-bt/2} \\cos(\\omega t - \\delta)\\] where \\( \\theta_0 \\) and \\( \\delta \\) depend on the system parameters. Resonance Conditions Resonance occurs when the driving frequency \\( \\omega \\) matches the natural frequency: \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] At resonance, the amplitude grows significantly unless limited by damping. Analysis of Dynamics Effects of Parameters Damping coefficient ( \\( b \\) ) : Higher damping reduces oscillation amplitude and affects stability. Driving amplitude ( \\( A \\) ) : Higher values increase oscillation response and can induce chaotic behavior. Driving frequency ( \\( \\omega \\) ) : Near resonance, large oscillations appear, leading to energy amplification. Transition to Chaos Beyond simple oscillations, varying \\( b \\) , \\( A \\) , and \\( \\omega \\) leads to quasiperiodic or chaotic motion. The transition to chaos can be observed using bifurcation diagrams and Poincar\u00e9 sections. These chaotic behaviors arise from the system\u2019s sensitivity to initial conditions, a hallmark of deterministic chaos. Practical Applications Energy Harvesting : Used in piezoelectric devices to convert oscillatory motion into electrical energy. Suspension Bridges : Models forced oscillations under periodic forces, such as wind or traffic-induced vibrations. Oscillating Circuits : Analogous to driven RLC circuits, where voltage replaces angular displacement and current replaces velocity. Biological Rhythms : Similar dynamics appear in human gait patterns and circadian rhythms under external influences. Seismic Engineering : Structures subjected to periodic seismic forcing can be analyzed using pendulum models. Planetary Motion : Certain planetary rotational dynamics exhibit nonlinear oscillatory behavior similar to forced pendulums. Graphical Representations Time Series : Plots of \\( \\theta(t) \\) to observe periodicity or chaos. Learn more. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def forced_damped_pendulum(t, y, b, g, L, A, omega_d): \"\"\"ODE system for a forced damped pendulum.\"\"\" theta, omega = y # omega represents angular velocity (dtheta/dt) dtheta_dt = omega domega_dt = -b * omega - (g/L) * np.sin(theta) + A * np.cos(omega_d * t) # Corrected force term return [dtheta_dt, domega_dt] # Parameters g = 9.81 # Gravity (m/s^2) L = 1.0 # Length of pendulum (m) y0 = [np.pi / 4, 0] # Initial angle = 45 degrees, initial velocity = 0 # Different parameter sets to compare cases = [ {\"b\": 0.2, \"A\": 1.0, \"omega_d\": 1.5, \"label\": \"b=0.2, A=1.0, \u03c9=1.5\"}, {\"b\": 0.5, \"A\": 1.2, \"omega_d\": 2.0, \"label\": \"b=0.5, A=1.2, \u03c9=2.0\"}, {\"b\": 0.8, \"A\": 1.5, \"omega_d\": 2.5, \"label\": \"b=0.8, A=1.5, \u03c9=2.5\"}, ] # Time range t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 1000) plt.figure(figsize=(12, 7.5)) # Solve and plot for different cases for case in cases: sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(case[\"b\"], g, L, case[\"A\"], case[\"omega_d\"])) plt.plot(sol.t, sol.y[0], label=case[\"label\"]) # Formatting the plot plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.title('Forced Damped Pendulum Motion (Multiple Instances)') plt.legend() plt.grid(True) plt.show() Phase Portraits : \\( \\theta \\) vs. \\( \\frac{d\\theta}{dt} \\) to analyze system stability and attractors. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def forced_damped_pendulum(t, y, b, g, L, A, omega): \"\"\"ODE system for a forced damped pendulum.\"\"\" theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g/L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters g = 9.81 # Gravity (m/s\u00b2) L = 1.0 # Length of pendulum (m) y0 = [np.pi / 4, 0] # Initial angle = 45 degrees, initial velocity = 0 # Different parameter sets to compare cases = [ {\"b\": 0.2, \"A\": 1.0, \"omega\": 1.5, \"color\": \"r\", \"label\": \"b=0.2, A=1.0, \u03c9=1.5\"}, {\"b\": 0.5, \"A\": 1.2, \"omega\": 2.0, \"color\": \"b\", \"label\": \"b=0.5, A=1.2, \u03c9=2.0\"}, {\"b\": 0.8, \"A\": 1.5, \"omega\": 2.5, \"color\": \"g\", \"label\": \"b=0.8, A=1.5, \u03c9=2.5\"}, ] # Time range t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 1000) plt.figure(figsize=(12, 7.5)) # Solve and plot for different cases for case in cases: sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(case[\"b\"], g, L, case[\"A\"], case[\"omega\"])) plt.plot(sol.y[0], sol.y[1], color=case[\"color\"], label=case[\"label\"]) # Formatting plt.xlabel('Theta (angle)') plt.ylabel('Angular Velocity') plt.title('Phase Portrait of Forced Damped Pendulum') plt.legend() plt.grid(True) plt.show() Poincar\u00e9 Sections : Used to detect chaotic behavior by sampling system states at discrete time intervals. Bifurcation Diagrams : Show transitions to complex motion as system parameters are varied, revealing period-doubling cascades leading to chaos. Lyapunov Exponents : Used to quantify chaos by measuring the rate of separation of nearby trajectories. Conclusion This study of the forced damped pendulum provides insight into nonlinear dynamics, resonance, and chaos, with applications in physics and engineering. By using numerical simulations, we can explore a range of behaviors from simple periodic motion to chaotic dynamics, offering deeper understanding and practical implications in various scientific domains. The forced damped pendulum serves as a fundamental model for diverse physical systems, reinforcing the significance of nonlinear dynamics in both theoretical and applied research.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a fascinating example of a system where damping, restoring forces, and external periodic forcing interplay to create rich dynamic behavior. This system exhibits a variety of phenomena, including resonance, chaos, and quasiperiodicity, making it a valuable subject for studying complex real-world systems such as driven oscillators, climate models, and mechanical structures under periodic stress. By adjusting parameters like damping, external force amplitude, and driving frequency, the system transitions through different behaviors, such as synchronized oscillations, chaotic motion, and resonance phenomena. Understanding these behaviors has significant implications for fields like energy harvesting, vibration isolation, and mechanical resonance.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#theoretical-foundation","text":"The motion of a forced damped pendulum is governed by the differential equation: \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t)\\] where: \\( \\theta(t) \\) is the angular displacement, \\( b \\) is the damping coefficient, \\( g \\) is the gravitational acceleration, \\( L \\) is the length of the pendulum, \\( A \\) is the amplitude of the external force, \\( \\omega \\) is the driving frequency.","title":"Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small angles, we approximate \\( \\sin\\theta \\approx \\theta \\) , reducing the equation to: \\[\\frac{d^2\\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t)\\] This equation describes a forced damped harmonic oscillator with the general solution: \\[\\theta(t) = \\theta_0 e^{-bt/2} \\cos(\\omega t - \\delta)\\] where \\( \\theta_0 \\) and \\( \\delta \\) depend on the system parameters.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions","text":"Resonance occurs when the driving frequency \\( \\omega \\) matches the natural frequency: \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] At resonance, the amplitude grows significantly unless limited by damping.","title":"Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#analysis-of-dynamics","text":"","title":"Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effects-of-parameters","text":"Damping coefficient ( \\( b \\) ) : Higher damping reduces oscillation amplitude and affects stability. Driving amplitude ( \\( A \\) ) : Higher values increase oscillation response and can induce chaotic behavior. Driving frequency ( \\( \\omega \\) ) : Near resonance, large oscillations appear, leading to energy amplification.","title":"Effects of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-to-chaos","text":"Beyond simple oscillations, varying \\( b \\) , \\( A \\) , and \\( \\omega \\) leads to quasiperiodic or chaotic motion. The transition to chaos can be observed using bifurcation diagrams and Poincar\u00e9 sections. These chaotic behaviors arise from the system\u2019s sensitivity to initial conditions, a hallmark of deterministic chaos.","title":"Transition to Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#practical-applications","text":"Energy Harvesting : Used in piezoelectric devices to convert oscillatory motion into electrical energy. Suspension Bridges : Models forced oscillations under periodic forces, such as wind or traffic-induced vibrations. Oscillating Circuits : Analogous to driven RLC circuits, where voltage replaces angular displacement and current replaces velocity. Biological Rhythms : Similar dynamics appear in human gait patterns and circadian rhythms under external influences. Seismic Engineering : Structures subjected to periodic seismic forcing can be analyzed using pendulum models. Planetary Motion : Certain planetary rotational dynamics exhibit nonlinear oscillatory behavior similar to forced pendulums.","title":"Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#graphical-representations","text":"Time Series : Plots of \\( \\theta(t) \\) to observe periodicity or chaos. Learn more. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def forced_damped_pendulum(t, y, b, g, L, A, omega_d): \"\"\"ODE system for a forced damped pendulum.\"\"\" theta, omega = y # omega represents angular velocity (dtheta/dt) dtheta_dt = omega domega_dt = -b * omega - (g/L) * np.sin(theta) + A * np.cos(omega_d * t) # Corrected force term return [dtheta_dt, domega_dt] # Parameters g = 9.81 # Gravity (m/s^2) L = 1.0 # Length of pendulum (m) y0 = [np.pi / 4, 0] # Initial angle = 45 degrees, initial velocity = 0 # Different parameter sets to compare cases = [ {\"b\": 0.2, \"A\": 1.0, \"omega_d\": 1.5, \"label\": \"b=0.2, A=1.0, \u03c9=1.5\"}, {\"b\": 0.5, \"A\": 1.2, \"omega_d\": 2.0, \"label\": \"b=0.5, A=1.2, \u03c9=2.0\"}, {\"b\": 0.8, \"A\": 1.5, \"omega_d\": 2.5, \"label\": \"b=0.8, A=1.5, \u03c9=2.5\"}, ] # Time range t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 1000) plt.figure(figsize=(12, 7.5)) # Solve and plot for different cases for case in cases: sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(case[\"b\"], g, L, case[\"A\"], case[\"omega_d\"])) plt.plot(sol.t, sol.y[0], label=case[\"label\"]) # Formatting the plot plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.title('Forced Damped Pendulum Motion (Multiple Instances)') plt.legend() plt.grid(True) plt.show() Phase Portraits : \\( \\theta \\) vs. \\( \\frac{d\\theta}{dt} \\) to analyze system stability and attractors. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp def forced_damped_pendulum(t, y, b, g, L, A, omega): \"\"\"ODE system for a forced damped pendulum.\"\"\" theta, omega_dot = y dtheta_dt = omega_dot domega_dt = -b * omega_dot - (g/L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters g = 9.81 # Gravity (m/s\u00b2) L = 1.0 # Length of pendulum (m) y0 = [np.pi / 4, 0] # Initial angle = 45 degrees, initial velocity = 0 # Different parameter sets to compare cases = [ {\"b\": 0.2, \"A\": 1.0, \"omega\": 1.5, \"color\": \"r\", \"label\": \"b=0.2, A=1.0, \u03c9=1.5\"}, {\"b\": 0.5, \"A\": 1.2, \"omega\": 2.0, \"color\": \"b\", \"label\": \"b=0.5, A=1.2, \u03c9=2.0\"}, {\"b\": 0.8, \"A\": 1.5, \"omega\": 2.5, \"color\": \"g\", \"label\": \"b=0.8, A=1.5, \u03c9=2.5\"}, ] # Time range t_span = (0, 50) t_eval = np.linspace(t_span[0], t_span[1], 1000) plt.figure(figsize=(12, 7.5)) # Solve and plot for different cases for case in cases: sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(case[\"b\"], g, L, case[\"A\"], case[\"omega\"])) plt.plot(sol.y[0], sol.y[1], color=case[\"color\"], label=case[\"label\"]) # Formatting plt.xlabel('Theta (angle)') plt.ylabel('Angular Velocity') plt.title('Phase Portrait of Forced Damped Pendulum') plt.legend() plt.grid(True) plt.show() Poincar\u00e9 Sections : Used to detect chaotic behavior by sampling system states at discrete time intervals. Bifurcation Diagrams : Show transitions to complex motion as system parameters are varied, revealing period-doubling cascades leading to chaos. Lyapunov Exponents : Used to quantify chaos by measuring the rate of separation of nearby trajectories.","title":"Graphical Representations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#conclusion","text":"This study of the forced damped pendulum provides insight into nonlinear dynamics, resonance, and chaos, with applications in physics and engineering. By using numerical simulations, we can explore a range of behaviors from simple periodic motion to chaotic dynamics, offering deeper understanding and practical implications in various scientific domains. The forced damped pendulum serves as a fundamental model for diverse physical systems, reinforcing the significance of nonlinear dynamics in both theoretical and applied research.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"}]}